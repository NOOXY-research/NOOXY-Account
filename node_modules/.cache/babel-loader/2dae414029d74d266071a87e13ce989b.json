{"ast":null,"code":"// NoService/clients/javascript/NSc.js\n// Description:\n// \"NSc.js\" is a NoNoService framework client.\n// Copyright 2018-2019 NOOXY. All Rights Reserved.\n'use strict'; // const WebSocket = require('ws');\n// const crypto = require('crypto');\n// initialization\n\nString.prototype.replaceAll = function (search, replacement) {\n  var target = this;\n  return target.split(search).join(replacement);\n}; // initialization end\n\n\nvar Buf = {\n  alloc: function alloc() {// return Buffer.alloc.apply(null, args);\n  },\n  encode: function encode() {\n    // console.log( new TextEncoder('utf-8').encode(args[0]));\n    return new Uint8Array(new TextEncoder('utf-8').encode(arguments.length <= 0 ? undefined : arguments[0]));\n  },\n  decode: function decode() {\n    return new TextDecoder('utf-8').decode(arguments.length <= 0 ? undefined : arguments[0]);\n  },\n  concat: function concat() {\n    var len = 0;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i in args[0]) {\n      len += args[0][i].length;\n    }\n\n    var result = new Uint8Array(len);\n    len = 0;\n\n    for (var _i in args[0]) {\n      result.set(args[0][_i], len);\n      len += args[0][_i].length;\n    }\n\n    return result;\n  },\n  isBuffer: function isBuffer() {\n    return (arguments.length <= 0 ? undefined : arguments[0]) instanceof Uint8Array;\n  }\n};\n\nfunction NSc(targetip, method, targetport) {\n  var setCookie = function setCookie(cname, cvalue, exdays) {\n    console.log(cname, cvalue, exdays);\n    var d = new Date();\n    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);\n    var expires = \"expires=\" + d.toUTCString();\n    document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\n  };\n\n  var getCookie = function getCookie(cname) {\n    var name = cname + \"=\";\n    var ca = document.cookie.split(';');\n\n    for (var i = 0; i < ca.length; i++) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1);\n      }\n\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length);\n      }\n    }\n\n    return \"\";\n  };\n\n  var eraseCookie = function eraseCookie(name) {\n    setCookie(name, \"\", -1);\n  };\n\n  var settings = {\n    verbose: true,\n    debug: false,\n    user: null,\n    secure: true,\n    NSc_files_root: '/',\n    connmethod: 'WebSocketSecure',\n    targetip: '0.0.0.0',\n    targetport: 43581\n  };\n  var Constants = {\n    'version': '0.5.0',\n    'NSP_version': '0.5.0',\n    'copyright': 'copyright(c)2018-2019 NOOXY inc.',\n    \"CONNECTION_METHOD_NAME_MAP\": {\n      \"TCP\": \"TCP\",\n      \"WebSocket\": \"WebSocket\",\n      \"WebSocketSecure\": \"WebSocketSecure\",\n      \"Local\": \"Local\",\n      \"TCP/IP\": \"TCP\",\n      \"ws\": \"WebSocket\",\n      \"wss\": \"WebSocketSecure\",\n      \"local\": \"Local\"\n    }\n  };\n  var Utils = {\n    getQueryVariable: function getQueryVariable(variable) {\n      var query = window.location.search.substring(1);\n      var vars = query.split(\"&\");\n\n      for (var i = 0; i < vars.length; i++) {\n        var pair = vars[i].split(\"=\");\n\n        if (pair[0] == variable) {\n          return pair[1];\n        }\n      }\n\n      return false;\n    },\n    Base64toArrayBuffer: function Base64toArrayBuffer(b64str) {\n      var raw = window.atob(b64str);\n      var rawLength = raw.length;\n      var array = new Uint8Array(new ArrayBuffer(rawLength));\n\n      for (var i = 0; i < rawLength; i++) {\n        array[i] = raw.charCodeAt(i);\n      }\n\n      return array;\n    },\n    convertPemToBinary: function convertPemToBinary(pem) {\n      var lines = pem.split('\\n');\n      var encoded = '';\n\n      for (var i = 0; i < lines.length; i++) {\n        if (lines[i].trim().length > 0 && lines[i].indexOf('-----BEGIN RSA PRIVATE KEY-----') < 0 && lines[i].indexOf('-----BEGIN RSA PUBLIC KEY-----') < 0 && lines[i].indexOf('-----BEGIN PUBLIC KEY-----') < 0 && lines[i].indexOf('-----END PUBLIC KEY-----') < 0 && lines[i].indexOf('-----BEGIN PRIVATE KEY-----') < 0 && lines[i].indexOf('-----END PRIVATE KEY-----') < 0 && lines[i].indexOf('-----END RSA PRIVATE KEY-----') < 0 && lines[i].indexOf('-----END RSA PUBLIC KEY-----') < 0) {\n          encoded += lines[i].trim();\n        }\n      }\n\n      return Utils.Base64toArrayBuffer(encoded);\n    },\n    ArrayBuffertoBase64: function ArrayBuffertoBase64(buffer) {\n      var binary = '';\n      var bytes = new Uint8Array(buffer);\n      var len = bytes.byteLength;\n\n      for (var i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n      }\n\n      return window.btoa(binary);\n    },\n    printLOGO: function printLOGO(version, copyright) {\n      console.log('88b 88  dP\\'Yb   dP\\'Yb  Yb  dP Yb  dP  TM');\n      console.log('88Yb88 dP   Yb dP   Yb  YbdP   YbdP  ');\n      console.log('88 Y88 Yb   dP Yb   dP  dPYb    88   ');\n      console.log('88  Y8  YbodP   YbodP  dP  Yb   88   NoService framework. ');\n      console.log('');\n      console.log('');\n      console.log('ver. ' + version + '. ' + copyright);\n      console.log('For more information or update -> www.nooxy.org');\n      console.log('');\n    },\n    TagLog: function TagLog(tag, logstring) {\n      if (typeof logstring != 'string') {\n        logstring = JSON.stringify(logstring, null, 2);\n      }\n\n      var _space = 10;\n      tag = tag.substring(0, _space);\n\n      for (var i = 0; i < _space - tag.length; i++) {\n        if (i % 2 != 1) {\n          tag = tag + ' ';\n        } else {\n          tag = ' ' + tag;\n        }\n      }\n\n      console.log('[' + tag + '] ' + logstring.replaceAll('\\n', '\\n[' + tag + '] '));\n    },\n    generateUniqueId: function generateUniqueId() {\n      return '_' + Math.random().toString(36).substr(2, 9);\n    },\n    generateGUID: function generateGUID() {\n      var s4 = function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      };\n\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n    },\n    searchObject: function searchObject(object, value) {\n      for (var prop in object) {\n        if (object.hasOwnProperty(prop)) {\n          if (object[prop] === value) {\n            return prop;\n          }\n        }\n      }\n    } // NoService Modules\n\n  };\n  var Connections = {\n    WebSocket: {\n      Client: function Client(ConnectionProfile) {\n        var _this = this;\n\n        var _ws = null;\n\n        var _debug;\n\n        this.setDebug = function (d) {\n          _debug = d;\n        };\n\n        this.closeConnetion = function () {\n          _ws.close();\n        };\n\n        this.onData = function (connprofile, data) {\n          Utils.TagLog('*ERR*', 'onData not implemented');\n        };\n\n        this.onClose = function () {\n          Utils.TagLog('*ERR*', 'onClose not implemented');\n        };\n\n        this.send = function (connprofile, data) {\n          _ws.send(data);\n        };\n\n        this.connect = function (ip, port, callback) {\n          var connprofile;\n          _ws = new WebSocket('ws://' + ip + ':' + port);\n          _ws.binaryType = \"arraybuffer\";\n          connprofile = new ConnectionProfile(null, 'Server', 'WebSocket', ip, port, 'localhost', _this);\n\n          _ws.onopen = function () {\n            callback(false, connprofile); // ws.send('something');\n          };\n\n          _ws.onmessage = function (event) {\n            _this.onData(connprofile, new Uint8Array(event.data));\n          };\n\n          _ws.onerror = function (error) {\n            if (_debug) {\n              Utils.TagLog('*WARN*', 'An error occured on connection module.');\n              Utils.TagLog('*WARN*', error);\n            }\n\n            _ws.close();\n\n            _this.onClose(connprofile);\n          };\n\n          _ws.onclose = function (error) {\n            _this.onClose(connprofile);\n          };\n        };\n      }\n    },\n    WebSocketSecure: {\n      Client: function Client(ConnectionProfile) {\n        var _this2 = this;\n\n        var _ws = null;\n\n        var _debug;\n\n        this.setDebug = function (d) {\n          _debug = d;\n        };\n\n        this.closeConnetion = function () {\n          _ws.close();\n        };\n\n        this.onData = function (connprofile, data) {\n          Utils.TagLog('*ERR*', 'onData not implemented');\n        };\n\n        this.onClose = function () {\n          Utils.TagLog('*ERR*', 'onClose not implemented');\n        };\n\n        this.send = function (connprofile, data) {\n          _ws.send(data);\n        };\n\n        this.connect = function (ip, port, callback) {\n          var connprofile;\n          _ws = new WebSocket('wss://' + ip + ':' + port);\n          _ws.binaryType = \"arraybuffer\";\n          connprofile = new ConnectionProfile(null, 'Server', 'WebSocketSecure', ip, port, 'localhost', _this2);\n\n          _ws.onopen = function () {\n            callback(false, connprofile); // ws.send('something');\n          };\n\n          _ws.onmessage = function (event) {\n            _this2.onData(connprofile, new Uint8Array(event.data));\n          };\n\n          _ws.onerror = function (error) {\n            if (_debug) {\n              Utils.TagLog('*WARN*', 'An error occured on connection module.');\n              Utils.TagLog('*WARN*', error);\n            }\n\n            _ws.close();\n\n            _this2.onClose(connprofile);\n          };\n\n          _ws.onclose = function (error) {\n            _this2.onClose(connprofile);\n          };\n        };\n      }\n    }\n  };\n\n  function Connection(options) {\n    var _this4 = this;\n\n    if (options.allow_ssl_self_signed) process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n    var _default_local_ip_and_port = '';\n    var _servers = {};\n    var _clients = {};\n    var _have_local_server = false;\n    var _blocked_ip = [];\n    var ssl_priv_key;\n    var ssl_cert;\n    var uint16_heartbeat_phrase = Buf.encode('HB');\n    var heartbeat_cycle = 60000;\n    var _debug = false;\n\n    var _conn_meth_name_map; // define an profile of an connection\n\n\n    function ConnectionProfile(serverId, Rpos, connMethod, hostip, hostport, clientip, conn) {\n      var _this3 = this;\n\n      var _serverId = serverId;\n      var _pos = Rpos;\n      var _connMethod = connMethod;\n      var _bundle = {};\n\n      var _GUID = Utils.generateGUID();\n\n      var _hostip = hostip;\n      var _hostport = hostport;\n      var _clientip = clientip;\n      var _conn = conn; // conn is wrapped!\n\n      if (Rpos === 'Server') {\n        _clients[connMethod + hostip + hostport] = this;\n      }\n\n      this.closeConnetion = function () {\n        if (Rpos === 'Server') {\n          delete _clients[connMethod + hostip + hostport];\n        } // Utils.TagLog('*ERR*', 'closeConnetion not implemented. Of '+this.type);\n\n\n        _conn.closeConnetion(_GUID);\n      };\n\n      this.getServerId = function (callback) {\n        callback(false, _serverId);\n      };\n\n      this.getHostIP = function (callback) {\n        callback(false, _hostip);\n      };\n\n      this.getHostPort = function (callback) {\n        callback(false, _hostport);\n      };\n\n      this.getClientIP = function (callback) {\n        callback(false, _clientip);\n      };\n\n      this.getConnMethod = function (callback) {\n        callback(false, _connMethod);\n      };\n\n      this.getRemotePosition = function (callback) {\n        callback(false, _pos);\n      };\n\n      this.setBundle = function (key, value) {\n        _bundle[key] = value;\n      };\n\n      this.getBundle = function (key, callback) {\n        callback(false, _bundle[key]);\n      };\n\n      this.getConn = function (callback) {\n        callback(false, _conn);\n      };\n\n      this.getGUID = function (callback) {\n        callback(false, _GUID);\n      };\n\n      this.returnServerId = function () {\n        return _serverId;\n      };\n\n      this.returnHostIP = function () {\n        return _hostip;\n      };\n\n      this.returnHostPort = function () {\n        return _hostport;\n      };\n\n      this.returnClientIP = function () {\n        return _clientip;\n      };\n\n      this.returnConnMethod = function () {\n        return _connMethod;\n      };\n\n      this.returnRemotePosition = function () {\n        return _pos;\n      };\n\n      this.returnBundle = function (key) {\n        return _bundle[key];\n      };\n\n      this.returnConn = function () {\n        return _conn;\n      };\n\n      this.returnGUID = function () {\n        return _GUID;\n      };\n\n      this.destroy = function () {\n        // for worker deletetion\n        _this3.worker_cancel_refer = true;\n        delete _clients[_GUID];\n      }; // this.onConnectionDropout = () => {\n      //   Utils.TagLog('*ERR*', 'onConnectionDropout not implemented');\n      // }\n\n    }\n\n    this.addServer = function (conn_method, ip, port) {\n      if (conn_method === 'local' || conn_method == 'Local') {\n        if (_have_local_server === false) {\n          var _serverId = \"LOCAL\";\n          var server = new Connections.Local.Server(_serverId, ConnectionProfile);\n          _servers[_serverId] = server;\n          server.start('LOCALIP', 'LOCALPORT');\n          server.onData = _this4.onData;\n          server.onClose = _this4.onClose;\n          _have_local_server = true;\n        } else {\n          Utils.TagLog('*ERR*', 'Can only exist one local server.');\n        }\n      } else if (_conn_meth_name_map[conn_method]) {\n        var _serverId2 = Utils.generateUniqueId();\n\n        var _server = new Connections[_conn_meth_name_map[conn_method]].Server(_serverId2, ConnectionProfile, ssl_priv_key, ssl_cert);\n\n        _servers[_serverId2] = _server;\n\n        _server.start(ip, port);\n\n        _server.onData = _this4.onData;\n        _server.onClose = _this4.onClose;\n      } else {\n        Utils.TagLog('*ERR*', 'ConnMethod ' + conn_method + ' not implemented. Skipped.');\n      } // Heartbeat\n\n\n      if (Object.keys(_servers).length == 1) {\n        setInterval(function () {\n          for (var i in _servers) {\n            try {\n              _servers[i].broadcast(uint16_heartbeat_phrase);\n            } catch (e) {\n              if (_debug) {\n                Utils.TagLog('*WARN*', 'Server ' + i + ' occured error on heartbeat. Skipped.');\n              }\n            }\n          }\n\n          ;\n        }, heartbeat_cycle);\n      }\n\n      ;\n    };\n\n    this.createClient = function (conn_method, remoteip, port, callback) {\n      // Heartbeat\n      var onData_wrapped = function onData_wrapped(connprofile, data) {\n        if (data.length != uint16_heartbeat_phrase.length || data[0] != uint16_heartbeat_phrase[0] || data[1] != uint16_heartbeat_phrase[1]) {\n          _this4.onData(connprofile, data);\n        } else {}\n      };\n\n      var _prev_client = _clients[conn_method + remoteip + port];\n\n      if (_prev_client) {\n        callback(false, _prev_client);\n      } else if (conn_method === 'local' || conn_method == 'Local') {\n        if (_have_local_server === false) {\n          Utils.TagLog('*ERR*', 'Local server not started.');\n        } else {\n          var locc = new Connections.Local.Client(ConnectionProfile);\n          locc.setDebug(_debug);\n          locc.onData = onData_wrapped;\n          locc.onClose = _this4.onClose;\n          locc.connect('LOCALIP', 'LOCALPORT', callback);\n        }\n      } else if (_conn_meth_name_map[conn_method]) {\n        var netc = new Connections[_conn_meth_name_map[conn_method]].Client(ConnectionProfile);\n        netc.setDebug(_debug);\n        netc.onData = onData_wrapped;\n        netc.onClose = _this4.onClose;\n        netc.connect(remoteip, port, callback);\n      } else {\n        Utils.TagLog('*ERR*', 'ConnMethod ' + conn_method + ' not implemented. Skipped.');\n      }\n    };\n\n    this.addConnetionModule = function (constructor) {\n      Connections[constructor.ConnectMethod] = constructor;\n    };\n\n    this.send = function (connprofile, data) {\n      try {\n        connprofile.getConn(function (err, conn) {\n          conn.send(connprofile, data);\n        });\n      } catch (e) {\n        if (_debug) {\n          Utils.TagLog('*WARN*', 'Error occured while sending Data.');\n          console.log(e);\n        }\n      }\n    };\n\n    this.broadcast = function (data) {\n      try {\n        _servers.forEach(function (key, server) {\n          server.broadcast(data);\n        });\n      } catch (e) {\n        if (_debug) {\n          Utils.TagLog('*WARN*', 'Error occured while broadcasting Data.');\n          console.log(e);\n        }\n      }\n    };\n\n    this.onData = function (conn_profile, data) {\n      Utils.TagLog('*ERR*', 'Connection module onData not implement');\n    };\n\n    this.onClose = function (connprofile) {\n      Utils.TagLog('*ERR*', 'Connection module onClose not implement');\n    };\n\n    this.getServers = function (callback) {\n      callback(false, _servers);\n    };\n\n    this.getClients = function (callback) {\n      callback(false, _clients);\n    };\n\n    this.killClient = function (conn_profile) {};\n\n    this.setDebug = function (bool) {\n      _debug = bool;\n    };\n\n    this.importSSLCert = function (ssl_cert_in) {\n      ssl_cert = ssl_cert_in;\n    };\n\n    this.importSSLPrivateKey = function (ssl_priv_key_in) {\n      ssl_priv_key = ssl_priv_key_in;\n    };\n\n    this.importHeartBeatCycle = function (cycle) {\n      heartbeat_cycle = cycle;\n    };\n\n    this.importConnectionMethodNameMap = function (dict) {\n      _conn_meth_name_map = dict;\n    };\n\n    this.close = function () {\n      _this4.onClose = function (connprofile) {\n        Utils.TagLog('*ERR*', 'Connection module onClose not implement');\n      };\n\n      _this4.onData = function (conn_profile, data) {\n        Utils.TagLog('*ERR*', 'Connection module onData not implement');\n      };\n\n      for (var i in _clients) {\n        _clients[i].closeConnetion();\n      }\n\n      for (var _i2 in _servers) {\n        _servers[_i2].close();\n      }\n    };\n  }\n\n  var Protocols = [function Protocol(coregateway, emitRequest) {\n    this.Protocol = \"AU\";\n    this.Positions = {\n      rq: \"Server\",\n      rs: \"Client\"\n    };\n    var Implementation = coregateway.Implementation;\n    var Entity = coregateway.Entity;\n    var Utils = coregateway.Utilities;\n    var AuthorizationHandler = coregateway.AuthorizationHandler;\n    var _queue_operation = {};\n    var _auth_timeout = 180; // ClientSide\n\n    var _handler = {\n      // Authby password\n      'PW': function PW(connprofile, data, emitResponse) {\n        AuthorizationHandler.AuthbyPassword(connprofile, data, emitResponse);\n      },\n      // Authby password failed\n      'PF': function PF(connprofile, data, emitResponse) {\n        AuthorizationHandler.AuthbyPasswordFailed(connprofile, data, emitResponse);\n      },\n      // Authby token\n      'TK': function TK(connprofile, data, emitResponse) {\n        AuthorizationHandler.AuthbyToken(connprofile, data, emitResponse);\n      },\n      // Authby token failed\n      'TF': function TF(connprofile, data, emitResponse) {\n        AuthorizationHandler.AuthbyTokenFailed(connprofile, data, emitResponse);\n      },\n      // Sign in\n      'SI': function SI(connprofile, data, emitResponse) {\n        AuthorizationHandler.Signin(connprofile, data, emitResponse);\n      },\n      'AF': function AF() {}\n    };\n\n    this.RequestHandler = function (connprofile, blob, emitResponse) {\n      var data = JSON.parse(Buf.decode(blob));\n\n      var _emitResponse = function _emitResponse(connprofile, data) {\n        emitResponse(connprofile, Buf.encode(JSON.stringify(data)));\n      };\n\n      _handler[data.m](connprofile, data, _emitResponse);\n    };\n  }, function Protocol(coregateway, emitRequest) {\n    this.Protocol = \"CS\";\n    this.Positions = {\n      rq: \"Client\",\n      rs: \"Server\"\n    };\n    var Activity = coregateway.Activity;\n    var Utils = coregateway.Utilities;\n    var _ActivityRsCEcallbacks = {};\n\n    var _to_blob = function _to_blob(data) {\n      if (Buf.isBuffer(data.d.d)) {\n        var blob_back = Buf.concat([data.d.d]);\n        data.d.d = null;\n        var blob_front = Buf.encode(JSON.stringify(data));\n        return Buf.concat([Buf.encode(('0000000000000000' + blob_front.length).slice(-16)), blob_front, Buf.encode(('0000000000000000' + blob_back.length).slice(-16)), blob_back]);\n      } else {\n        var blob = Buf.encode(JSON.stringify(data));\n        return Buf.concat([Buf.encode(('0000000000000000' + blob.length).slice(-16)), blob]);\n      }\n    };\n\n    var _parse_blob = function _parse_blob(blob) {\n      var length = parseInt(Buf.decode(blob.slice(0, 16)));\n      var json_data = JSON.parse(Buf.decode(blob.slice(16, 16 + length)));\n      blob = blob.slice(16 + length);\n\n      if (blob.length) {\n        var blob_data;\n        length = parseInt(Buf.decode(blob.slice(0, 16)));\n        blob_data = blob.slice(16, 16 + length);\n        json_data.d.d = blob_data;\n        return json_data;\n      } else {\n        return json_data;\n      }\n    };\n\n    Activity.on('createActivitySocketRq', function (method, targetport, owner, mode, service, targetip, daemon_authkey, callback) {\n      var err = false;\n      var _data = {\n        \"m\": \"CE\",\n        \"d\": {\n          t: Utils.generateGUID(),\n          o: owner,\n          m: mode,\n          s: service,\n          od: targetip,\n          k: daemon_authkey\n        }\n      };\n      coregateway.Connection.createClient(method, targetip, targetport, function (err, connprofile) {\n        _ActivityRsCEcallbacks[_data.d.t] = function (connprofile, data) {\n          callback(false, connprofile, data.d.i);\n        };\n\n        emitRequest(connprofile, 'CS', _to_blob(_data));\n      });\n    });\n    Activity.on('EmitSSBlobServiceFunctionRq', function (conn_profile, entityId, name, data, meta, tempid) {\n      var _data = {\n        \"m\": \"BS\",\n        \"d\": {\n          \"i\": entityId,\n          \"n\": name,\n          \"t\": tempid,\n          \"d\": data,\n          \"m\": meta\n        }\n      };\n      emitRequest(conn_profile, 'CS', _to_blob(_data));\n    });\n    Activity.on('EmitSSDataRq', function (conn_profile, entityId, d) {\n      var _data = {\n        \"m\": \"SS\",\n        \"d\": {\n          \"i\": entityId,\n          \"d\": d\n        }\n      };\n      emitRequest(conn_profile, 'CS', _to_blob(_data));\n    });\n    Activity.on('EmitSSServiceFunctionRq', function (conn_profile, entityId, name, data, tempid) {\n      var _data = {\n        \"m\": \"SF\",\n        \"d\": {\n          \"i\": entityId,\n          \"n\": name,\n          \"t\": tempid,\n          \"d\": data\n        }\n      };\n      emitRequest(conn_profile, 'CS', _to_blob(_data));\n    });\n    Activity.on('EmitASCloseRq', function (conn_profile, entityId) {\n      var _data = {\n        \"m\": \"CS\",\n        \"d\": {\n          \"i\": entityId\n        }\n      };\n      emitRequest(conn_profile, 'CS', _to_blob(_data));\n    }); // client\n\n    this.ResponseHandler = function (connprofile, blob) {\n      var data = _parse_blob(blob);\n\n      var methods = {\n        // nooxy service protocol implementation of \"Call Service: Vertify Connection\"\n        VE: function VE(connprofile, data) {\n          if (data.d.s === 'OK') {\n            Activity.launchActivitySocketByEntityId(data.d.i);\n          } else {\n            Activity.emitASClose(data.d.i);\n          }\n        },\n        // nooxy service protocol implementation of \"Call Service: ServiceSocket\"\n        SS: function SS(connprofile, data) {},\n        // nooxy service protocol implementation of \"Call Service: Blob ServiceFunction\"\n        BS: function BS(connprofile, data) {\n          if (data.d.s === 'OK') {\n            Activity.emitBSFReturn(data.d.i, false, data.d.t, data.d.d, data.d.m);\n          } else {\n            Activity.emitBSFReturn(data.d.i, true, data.d.t, data.d.d, data.d.m);\n          }\n        },\n        // nooxy service protocol implementation of \"Call Service: ServiceFunction\"\n        SF: function SF(connprofile, data) {\n          if (data.d.s === 'OK') {\n            Activity.emitSFReturn(data.d.i, false, data.d.t, data.d.d);\n          } else {\n            Activity.emitSFReturn(data.d.i, true, data.d.t, data.d.d);\n          }\n        },\n        // nooxy service protocol implementation of \"Call Service: createEntity\"\n        CE: function CE(connprofile, data) {\n          // tell server finish create\n          if (data.d.i != null) {\n            // create a description of this service entity.\n            _ActivityRsCEcallbacks[data.d.t](connprofile, data);\n\n            var _data = {\n              \"m\": \"VE\",\n              \"d\": {\n                \"i\": data.d.i\n              }\n            };\n            emitRequest(connprofile, 'CS', _to_blob(_data));\n          } else {\n            _ActivityRsCEcallbacks[data.d.t](connprofile, data);\n\n            delete _ActivityRsCEcallbacks[data.d.t];\n          }\n        } // call the callback.\n\n      };\n      methods[data.m](connprofile, data);\n    };\n  }, function Protocol(coregateway, emitRequest) {\n    this.Protocol = \"GT\";\n    this.Positions = {\n      rq: \"Client\",\n      rs: \"Server\"\n    };\n\n    this.ResponseHandler = function (connprofile, blob) {\n      var data = JSON.parse(Buf.decode(blob));\n\n      if (data.s === 'OK') {\n        coregateway.Implementation.onToken(connprofile, false, data.u, data.t);\n      } else {\n        coregateway.Implementation.onToken(connprofile, true, data.u, data.t);\n      }\n    };\n  }, function Protocol(coregateway, emitRequest) {\n    this.Protocol = \"CA\";\n    this.Positions = {\n      rq: \"Server\",\n      rs: \"Client\"\n    };\n    var Activity = coregateway.Activity;\n\n    var _to_blob = function _to_blob(data) {\n      if (Buf.isBuffer(data.d.d)) {\n        var blob_back = Buf.concat([data.d.d]);\n        data.d.d = null;\n        var blob_front = Buf.encode(JSON.stringify(data));\n        return Buf.concat([Buf.encode(('0000000000000000' + blob_front.length).slice(-16)), blob_front, Buf.encode(('0000000000000000' + blob_back.length).slice(-16)), blob_back]);\n      } else {\n        var blob = Buf.encode(JSON.stringify(data));\n        return Buf.concat([Buf.encode(('0000000000000000' + blob.length).slice(-16)), blob]);\n      }\n    };\n\n    var _parse_blob = function _parse_blob(blob) {\n      var length = parseInt(Buf.decode(blob.slice(0, 16)));\n      var json_data = JSON.parse(Buf.decode(blob.slice(16, 16 + length)));\n      blob = blob.slice(16 + length);\n\n      if (blob.length) {\n        var blob_data;\n        length = parseInt(Buf.decode(blob.slice(0, 16)));\n        blob_data = blob.slice(16, 16 + length);\n        json_data.d.d = blob_data;\n        return json_data;\n      } else {\n        return json_data;\n      }\n    };\n\n    this.RequestHandler = function (connprofile, blob, emitResponse) {\n      var data = _parse_blob(blob);\n\n      var methods = {\n        // nooxy service protocol implementation of \"Call Activity: ActivitySocket\"\n        AS: function AS() {\n          Activity.emitASData(data.d.i, data.d.d);\n          var _data = {\n            \"m\": \"AS\",\n            \"d\": {\n              // status\n              \"i\": data.d.i,\n              \"s\": \"OK\"\n            }\n          };\n          emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n        },\n        // nooxy service protocol implementation of \"Call Activity: Blob Event(with metadata)\"\n        BE: function BE() {\n          Activity.emitASBlobEvent(data.d.i, data.d.n, data.d.d, data.d.m);\n          var _data = {\n            \"m\": \"BE\",\n            \"d\": {\n              // status\n              \"i\": data.d.i,\n              \"s\": \"OK\"\n            }\n          };\n          emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n        },\n        // nooxy service protocol implementation of \"Call Activity: Event\"\n        EV: function EV() {\n          Activity.emitASEvent(data.d.i, data.d.n, data.d.d);\n          var _data = {\n            \"m\": \"EV\",\n            \"d\": {\n              // status\n              \"i\": data.d.i,\n              \"s\": \"OK\"\n            }\n          };\n          emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n        },\n        // nooxy service protocol implementation of \"Call Activity: Close ActivitySocket\"\n        CS: function CS() {\n          Activity.emitASClose(data.d.i);\n        } // call the callback.\n\n      };\n      methods[data.m](connprofile, data.d, emitResponse);\n    };\n  }];\n\n  function Router() {\n    var _this5 = this;\n\n    var _coregateway; // nooxy service protocol secure\n\n\n    var _json_sniffers = [];\n    var _raw_sniffers = []; // for signup timeout\n\n    var _locked_ip = [];\n    var _debug = false;\n\n    var _tellJSONSniffers = function _tellJSONSniffers(Json) {\n      for (var i in _json_sniffers) {\n        _json_sniffers[i](false, Json);\n      }\n    };\n\n    var _tellRAWSniffers = function _tellRAWSniffers(data) {\n      for (var i in _raw_sniffers) {\n        _raw_sniffers[i](false, data);\n      }\n    }; // in case of wrong session of the position\n\n\n    var _sessionnotsupport = function _sessionnotsupport(protocol, session, data) {\n      if (_debug) {\n        Utils.TagLog('*WARN*', 'session not support');\n        Utils.TagLog('*WARN*', protocol);\n        Utils.TagLog('*WARN*', session);\n        Utils.TagLog('*WARN*', data);\n      }\n    }; // a convinient function fo sending data\n\n\n    var _senddata = function _senddata(connprofile, method, session, blob) {\n      var blobfinal = Buf.concat([Buf.encode(method + session, 'utf8'), blob]); // finally sent the data through the connection.\n\n      if (connprofile) {\n        _coregateway.NSPS.isConnectionSecured(connprofile, function (secured) {\n          if (secured === true) {\n            _coregateway.NSPS.encrypt(connprofile, blobfinal, function (err, encrypted) {\n              if (!err) {\n                _coregateway.Connection.send(connprofile, encrypted);\n              } else if (_debug) {\n                console.log(err);\n                Utils.TagLog('*WARN*', err.stack);\n              }\n            });\n          } else {\n            _coregateway.Connection.send(connprofile, blobfinal);\n          }\n        });\n      }\n    }; // implementations of NOOXY Service Protocol methods\n\n\n    var methods = {};\n\n    this.addJSONSniffer = function (callback) {\n      _json_sniffers.push(callback);\n    };\n\n    this.addRAWSniffer = function (callback) {\n      _raw_sniffers.push(callback);\n    }; // emit specified method.\n\n\n    this.emitRequest = function (connprofile, method, blob) {\n      methods[method].emitRequest(connprofile, blob);\n    }; // import the accessbility of core resource\n\n\n    this.importCore = function (coregateway) {\n      _coregateway = coregateway;\n      _debug = _coregateway.Settings.debug; // while recieve a data from connection\n\n      _coregateway.Connection.onData = function (connprofile, data) {\n        _tellRAWSniffers(data);\n\n        try {\n          if (_coregateway.Settings.secure === true && connprofile.returnConnMethod() != 'Local' && connprofile.returnConnMethod() != 'local') {\n            // upgrade protocol\n            _coregateway.NSPS.decrypt(connprofile, data, function (err, decrypted) {\n              if (err && _coregateway.Settings.debug) {\n                console.log(err);\n              }\n\n              var method = Buf.decode(decrypted.slice(0, 2));\n              var session = Buf.decode(decrypted.slice(2, 4));\n              var blob = decrypted.slice(4);\n\n              _tellJSONSniffers({\n                method: method,\n                session: session,\n                data: Buf.decode(blob)\n              });\n\n              methods[method].RequestHandler(connprofile, session, blob);\n            });\n          } else {\n            var _method = Buf.decode(data.slice(0, 2));\n\n            var session = Buf.decode(data.slice(2, 4));\n            var blob = data.slice(4);\n\n            _tellJSONSniffers({\n              method: _method,\n              session: session,\n              data: Buf.decode(blob)\n            });\n\n            methods[_method].RequestHandler(connprofile, session, blob);\n          }\n        } catch (er) {\n          if (_debug) {\n            Utils.TagLog('*ERR*', 'An error occured in router module.');\n            console.log(er);\n          }\n        }\n      };\n\n      _coregateway.Connection.onClose = function (connprofile) {\n        try {\n          if (connprofile.returnRemotePosition() === 'Client') {\n            _coregateway.Service.emitConnectionClose(connprofile, function (err) {\n              connprofile.destroy();\n            });\n          } else {\n            _coregateway.Activity.emitConnectionClose(connprofile, function (err) {\n              connprofile.destroy();\n            });\n          }\n        } catch (er) {\n          if (_debug) {\n            Utils.TagLog('*WARN*', 'An error occured in router module.');\n            console.log(er);\n          }\n        }\n      }; // load protocols\n\n\n      Protocols.forEach(function (pt) {\n        var p = new pt(_coregateway, _this5.emitRequest, _debug);\n        methods[p.Protocol] = {\n          emitRequest: function emitRequest(connprofile, data) {\n            _senddata(connprofile, p.Protocol, 'rq', data);\n          },\n          RequestHandler: function RequestHandler(connprofile, session, data) {\n            connprofile.getRemotePosition(function (err, pos) {\n              if (p.Positions[session] === pos || p.Positions[session] === 'Both') {\n                var _emitResponse = function _emitResponse(connprofile, data) {\n                  _senddata(connprofile, p.Protocol, 'rs', data);\n                };\n\n                if (session === 'rq') {\n                  p.RequestHandler(connprofile, data, _emitResponse);\n                } else {\n                  p.ResponseHandler(connprofile, data);\n                }\n              } else {\n                _sessionnotsupport(p, session, data);\n              }\n            });\n          }\n        };\n      });\n      _coregateway.Implementation.getClientConnProfile = _coregateway.Connection.createClient;\n\n      _coregateway.Implementation.emitRequest = function (connprofile, method, json) {\n        _this5.emitRequest(connprofile, method, Buf.encode(JSON.stringify(json)));\n      };\n\n      _coregateway.Implementation.sendRouterData = _senddata;\n      _coregateway.NSPS.sendRouterData = _senddata;\n    }; // for plugins\n\n\n    this.addProtocol = function (pt) {\n      if (_debug) {\n        Utils.TagLog('Router', 'Added a additional protocol.');\n      }\n\n      Protocols.push(pt);\n    };\n\n    this.close = function () {\n      _coregateway = null;\n      _json_sniffers = [];\n      _raw_sniffers = [];\n      _locked_ip = [];\n    };\n  }\n\n  var SocketPair = {\n    ActivitySocket: function ActivitySocket(service_name, conn_profile, emitter, unbindActivitySocketList, debug) {\n      var _this6 = this;\n\n      // Service Socket callback\n      var _emitdata = emitter.Data;\n      var _emit_sfunc = emitter.ServiceFunction;\n      var _emit_blob_sfunc = emitter.BlobServiceFunction;\n      var _emitclose = emitter.Close;\n\n      var _entity_id;\n\n      var _launched = false;\n      var wait_ops = [];\n      var wait_launch_ops = [];\n      var _sfqueue = {};\n      var _bsfqueue = {};\n      var _on_dict = {\n        data: function data() {\n          if (debug) Utils.TagLog('*WARN*', 'ActivitySocket of service \"' + service_name + '\" on \"data\" not implemented');\n        },\n        close: function close() {\n          if (debug) Utils.TagLog('*WARN*', 'ActivitySocket of service \"' + service_name + '\" on \"close\" not implemented');\n        }\n      };\n      var _on_event = {};\n      var _on_blob_event = {}; // For waiting connection is absolutly established. We need to wrap operations and make it queued.\n\n      var exec = function exec(callback) {\n        if (_launched != false) {\n          callback();\n        } else {\n          wait_ops.push(callback);\n        }\n      };\n\n      this.launch = function () {\n        _launched = true;\n\n        for (var i in wait_ops) {\n          wait_ops[i]();\n        }\n      };\n\n      this.setEntityId = function (id) {\n        _entity_id = id;\n        var entities_prev = conn_profile.returnBundle('bundle_entities');\n\n        if (entities_prev != null) {\n          conn_profile.setBundle('bundle_entities', [_entity_id].concat(entities_prev));\n        } else {\n          conn_profile.setBundle('bundle_entities', [_entity_id]);\n        }\n      }; // ServiceFunction call\n\n\n      this.call = function (name, data, callback) {\n        var op = function op() {\n          var tempid = Utils.generateUniqueId();\n\n          _sfqueue[tempid] = function (err, returnvalue) {\n            callback(err, returnvalue);\n          };\n\n          _emit_sfunc(conn_profile, _entity_id, name, data, tempid);\n        };\n\n        exec(op);\n      }; // BlobServiceFunction call\n\n\n      this.callBlob = function (name, blob, meta, callback) {\n        var op = function op() {\n          var tempid = Utils.generateUniqueId();\n\n          _bsfqueue[tempid] = function (err, returnblob, meta) {\n            callback(err, returnblob, meta);\n          };\n\n          _emit_blob_sfunc(conn_profile, _entity_id, name, blob, meta, tempid);\n        };\n\n        exec(op);\n      };\n\n      this.getEntityId = function (callback) {\n        callback(false, _entity_id);\n      };\n\n      this.sendData = function (data) {\n        var op = function op() {\n          _emitdata(conn_profile, _entity_id, data);\n        };\n\n        exec(op);\n      };\n\n      this.on = function (type, callback) {\n        _on_dict[type] = callback;\n      };\n\n      this.onEvent = function (event, callback) {\n        _on_event[event] = callback;\n      };\n\n      this.onBlobEvent = function (event, callback) {\n        _on_blob_event[event] = callback;\n      };\n\n      this._emitData = function (data) {\n        _on_dict['data'](false, data);\n      };\n\n      this._emitBlobEvent = function (event, blob, meta) {\n        if (_on_blob_event[event]) _on_blob_event[event](false, blob, meta);\n      };\n\n      this._emitSFReturn = function (err, tempid, returnvalue) {\n        if (err) {\n          _sfqueue[tempid](err);\n        } else {\n          _sfqueue[tempid](err, returnvalue);\n        }\n\n        delete _sfqueue[tempid];\n      };\n\n      this._emitBSFReturn = function (err, tempid, returnblob, meta) {\n        if (err) {\n          _bsfqueue[tempid](err);\n        } else {\n          _bsfqueue[tempid](err, returnblob, meta);\n        }\n\n        delete _bsfqueue[tempid];\n      };\n\n      this._emitEvent = function (event, data) {\n        if (_on_event[event]) _on_event[event](false, data);\n      };\n\n      this._emitClose = function () {\n        _on_dict['close'](false);\n      };\n\n      this.remoteClosed = false;\n\n      this.unbindActivitySocketList = function () {\n        Utils.TagLog('*ERR*', '_aftercloseLaunched not implemented');\n      };\n\n      this.close = function () {\n        var op = function op() {\n          if (!_this6.remoteClosed) _emitclose(conn_profile, _entity_id);\n\n          _this6._emitClose();\n\n          var bundle = conn_profile.returnBundle('bundle_entities');\n\n          for (var i = bundle.length - 1; i >= 0; i--) {\n            if (bundle[i] === _entity_id) {\n              unbindActivitySocketList(_entity_id);\n              bundle.splice(i, 1);\n            }\n          }\n\n          conn_profile.setBundle('bundle_entities', bundle);\n\n          if (bundle.length === 0) {\n            conn_profile.closeConnetion();\n          }\n        };\n\n        exec(op);\n      };\n    }\n  };\n\n  function Activity() {\n    var _this7 = this;\n\n    var ActivitySocketDestroyTimeout = 1000;\n    var _ASockets = {};\n    var _admin_name = 'admin';\n\n    var _daemon_auth_key;\n\n    var _debug = false;\n    var _on_handler = {};\n\n    var _emmiter;\n\n    var _unbindActivitySocketList = function _unbindActivitySocketList(_entity_id) {\n      setTimeout(function () {\n        // tell worker abort referance\n        if (_ASockets[_entity_id]) _ASockets[_entity_id].worker_cancel_refer = true;\n        delete _ASockets[_entity_id];\n      }, ActivitySocketDestroyTimeout);\n    }; // Service module create activity socket\n\n\n    this.createActivitySocket = function (method, targetip, targetport, service, owner, callback) {\n      _emmiter = {\n        Data: _on_handler['EmitSSDataRq'],\n        ServiceFunction: _on_handler['EmitSSServiceFunctionRq'],\n        Close: _on_handler['EmitASCloseRq']\n      };\n\n      _on_handler['createActivitySocketRq'](method, targetport, owner, 'normal', service, targetip, false, function (err, connprofile, entityId) {\n        if (entityId) {\n          var _as = new SocketPair.ActivitySocket(service, connprofile, _emmiter, _unbindActivitySocketList, _debug);\n\n          _as.setEntityId(entityId);\n\n          var prev = connprofile.returnBundle();\n\n          if (!prev) {\n            prev = [];\n          }\n\n          connprofile.setBundle('bundle_entities', prev.concat(entityId));\n          _ASockets[entityId] = _as;\n          callback(false, _ASockets[entityId]);\n        } else {\n          callback(new Error('Could not create this entity for some reason.'));\n        }\n      });\n    };\n\n    this.createAdminDaemonActivitySocket = function (method, targetip, targetport, service, callback) {\n      _this7.createDaemonActivitySocket(method, targetip, targetport, service, _admin_name, callback);\n    };\n\n    this.createDaemonActivitySocket = function (method, targetip, targetport, service, owner, callback) {\n      _emmiter = {\n        Data: _on_handler['EmitSSDataRq'],\n        ServiceFunction: _on_handler['EmitSSServiceFunctionRq'],\n        BlobServiceFunction: _on_handler['EmitSSBlobServiceFunctionRq'],\n        Close: _on_handler['EmitASCloseRq']\n      };\n\n      _on_handler['createActivitySocketRq'](method, targetport, owner, 'daemon', service, targetip, _daemon_auth_key, function (err, connprofile, entityId) {\n        if (entityId) {\n          var _as = new SocketPair.ActivitySocket(service, connprofile, _emmiter, _unbindActivitySocketList, _debug);\n\n          _as.setEntityId(entityId);\n\n          var prev = connprofile.returnBundle();\n\n          if (!prev) {\n            prev = [];\n          }\n\n          connprofile.setBundle('bundle_entities', prev.concat(entityId));\n          _ASockets[entityId] = _as;\n          callback(false, _ASockets[entityId]);\n        } else {\n          callback(new Error('Could not create this entity for some reason.'));\n        }\n      });\n    };\n\n    this.emitASClose = function (entityId) {\n      _ASockets[entityId].remoteClosed = true;\n\n      _ASockets[entityId]._emitClose();\n    };\n\n    this.emitASData = function (entityId, data) {\n      _ASockets[entityId]._emitData(data);\n    };\n\n    this.emitBSFReturn = function (entityId, err, tempid, returnvalue, meta) {\n      _ASockets[entityId]._emitBSFReturn(err, tempid, returnvalue, meta);\n    };\n\n    this.emitSFReturn = function (entityId, err, tempid, returnvalue) {\n      _ASockets[entityId]._emitSFReturn(err, tempid, returnvalue);\n    };\n\n    this.emitASData = function (entityId, data) {\n      _ASockets[entityId]._emitData(data);\n    };\n\n    this.emitASEvent = function (entityId, event, data) {\n      _ASockets[entityId]._emitEvent(event, data);\n    };\n\n    this.emitASBlobEvent = function (entityId, event, blob, meta) {\n      _ASockets[entityId]._emitBlobEvent(event, blob, meta);\n    };\n\n    this.launchActivitySocketByEntityId = function (entityId) {\n      _ASockets[entityId].launch();\n    };\n\n    this.emitConnectionClose = function (connprofile, callback) {\n      var _entitiesId = connprofile.returnBundle('bundle_entities');\n\n      var _loop = function _loop(i) {\n        _ASockets[_entitiesId[i]]._emitClose();\n\n        setTimeout(function () {\n          // for worker abort referance\n          if (_ASockets[_entitiesId[i]]) {\n            _ASockets[_entitiesId[i]].worker_cancel_refer = true;\n            delete _ASockets[_entitiesId[i]];\n          }\n        }, ActivitySocketDestroyTimeout);\n      };\n\n      for (var i in _entitiesId) {\n        _loop(i);\n      }\n\n      callback(false);\n    };\n\n    this.setDefaultUsername = function (username) {\n      _admin_name = username;\n    };\n\n    this.setDebug = function (debug) {\n      _debug = debug;\n    };\n\n    this.importDaemonAuthKey = function (key) {\n      _daemon_auth_key = key;\n    };\n\n    this.on = function (event, callback) {\n      _on_handler[event] = callback;\n    };\n\n    this.close = function () {\n      ActivitySocketDestroyTimeout = 1000;\n\n      for (var i in _ASockets) {\n        _ASockets[i].worker_cancel_refer = true;\n        delete _ASockets[i];\n      }\n\n      _ASockets = {};\n      _emmiter = null;\n      _admin_name = 'admin';\n      _daemon_auth_key = null;\n      _debug = false;\n      _on_handler = {};\n    };\n  }\n\n  ; // Handling responses to authorization requests.\n\n  function AuthorizationHandler() {\n    var _this8 = this;\n\n    this.importImplementation = function (Implementation) {\n      _this8.AuthbyPassword = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        Implementation.returnImplement('AuthbyPassword').apply(null, args);\n      };\n\n      _this8.AuthbyToken = function () {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        Implementation.returnImplement('AuthbyToken').apply(null, args);\n      };\n\n      _this8.AuthbyTokenFailed = function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        Implementation.returnImplement('AuthbyTokenFailed').apply(null, args);\n      };\n\n      _this8.Signin = function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        Implementation.returnImplement('signin').apply(null, args);\n      };\n    };\n\n    this.close = function () {};\n  }\n\n  ;\n\n  function Implementation() {\n    var _implts = {\n      // NOOXY service protocol sercure end\n      // return for Server\n      AuthbyToken: function AuthbyToken() {\n        Utils.TagLog('*ERR*', 'AuthbyToken not implemented');\n      },\n      AuthbyTokenFailed: function AuthbyTokenFailed() {\n        Utils.TagLog('*ERR*', 'AuthbyTokenFailed not implemented');\n      },\n      // return for Server\n      AuthbyPassword: function AuthbyPassword() {\n        Utils.TagLog('*ERR*', 'AuthbyPassword not implemented');\n      },\n      AuthbyPasswordFailed: function AuthbyPasswordFailed() {\n        Utils.TagLog('*ERR*', 'AuthbyPasswordFailed not implemented');\n      },\n      // return for Client\n      signin: function signin() {\n        Utils.TagLog('*ERR*', 'signin not implemented');\n      },\n      // return for Client\n      signup: function signup() {\n        Utils.TagLog('*ERR*', 'signup not implemented');\n      },\n      onToken: function onToken() {\n        Utils.TagLog('*ERR*', 'onToken not implemented');\n      }\n    };\n\n    this.onToken = function (connprofile, status, username, token) {\n      _implts['onToken'](status, token, username);\n    };\n\n    this.setImplement = function (name, callback) {\n      _implts[name] = callback;\n    };\n\n    this.returnImplement = function (name) {\n      return _implts[name];\n    };\n\n    this.getImplement = function (name, callback) {\n      callback(false, _implts[name]);\n    };\n\n    this.returnImplementBundle = function () {\n      return _implts;\n    };\n\n    this.getClientConnProfile = function () {};\n\n    this.close = function () {};\n  } // NOOXY service protocol secure\n\n\n  function NSPS() {\n    var _this9 = this;\n\n    var _rsa_pub;\n\n    var _rsa_priv;\n\n    var _resumes = {};\n\n    var _crypto_module;\n\n    var _operation_timeout = 60; // seconds\n\n    this.emitRequest = function () {\n      console.log('[*ERR*] emitRequest not implemented');\n    }; // Nooxy service protocol secure request ClientSide\n    // in client need to be in implementation module\n\n\n    this.RequestHandler = function (connprofile, blob) {\n      var data = JSON.parse(Buf.decode(blob));\n      var host_rsa_pub = data.p;\n\n      var client_random_num = _crypto_module.returnRandomInt(99999);\n\n      connprofile.setBundle('host_rsa_pub_key', host_rsa_pub);\n\n      _crypto_module.generateAESCBC256KeyByHash(host_rsa_pub, client_random_num, function (err, aes_key) {\n        connprofile.setBundle('aes_256_cbc_key', aes_key);\n        var _data = {\n          r: client_random_num,\n          a: aes_key // aes key to vertify\n\n        };\n\n        _crypto_module.encryptString('RSA2048', host_rsa_pub, JSON.stringify(_data), function (err, encrypted) {\n          if (err) {\n            console.log(err);\n          } else {\n            _this9.sendRouterData(connprofile, 'SP', 'rs', Buf.encode(JSON.stringify(encrypted)));\n\n            connprofile.setBundle('NSPS', true);\n          }\n        });\n      });\n    };\n\n    this.encrypt = function (connprofile, blob, callback) {\n      connprofile.getBundle('aes_256_cbc_key', function (err, key) {\n        _crypto_module.encrypt('AESCBC256', key, blob, function (err, encrypted) {\n          callback(err, encrypted);\n        });\n      });\n    };\n\n    this.decrypt = function (connprofile, blob, callback) {\n      if (connprofile.returnBundle('NSPS') === 'pending') {\n        var _method2 = Buf.decode(blob.slice(0, 2));\n\n        if (_method2 === 'SP') {\n          var session = Buf.decode(blob.slice(2, 4));\n\n          if (session === 'rs') {\n            var data = blob.slice(4);\n\n            _this9.ResponseHandler(connprofile, data);\n          }\n        } else {\n          _resumes[connprofile.returnGUID()].push(function () {\n            callback(false, blob);\n          });\n        }\n      } else if (connprofile.returnBundle('NSPS') != true && connprofile.returnRemotePosition() === 'Client') {\n        _this9.upgradeConnection(connprofile, function (err, succeess) {\n          if (succeess) {\n            callback(false, blob);\n          } else {\n            connprofile.closeConnetion();\n          }\n\n          if (err) {\n            console.log(err);\n          }\n        });\n      } else if (connprofile.returnBundle('NSPS') != true && connprofile.returnRemotePosition() === 'Server') {\n        var _method3 = Buf.decode(blob.slice(0, 2));\n\n        if (_method3 === 'SP') {\n          var _session = Buf.decode(blob.slice(2, 4));\n\n          if (_session === 'rq') {\n            var _data2 = blob.slice(4);\n\n            _this9.RequestHandler(connprofile, _data2);\n          }\n        } else {\n          callback(false, blob);\n        }\n      } else if (connprofile.returnBundle('NSPS') === true) {\n        _crypto_module.decrypt('AESCBC256', connprofile.returnBundle('aes_256_cbc_key'), blob, function (err, decrypted) {\n          callback(err, decrypted);\n        });\n      }\n    };\n\n    this.isConnectionSecured = function (connprofile, callback) {\n      connprofile.getBundle('NSPS', function (err, NSPS) {\n        // if(NSPS === 'finalize') {\n        //   connprofile.setBundle('NSPS', true);\n        //   callback(false);\n        // }\n        // else {\n        callback(NSPS); // }\n      });\n    };\n\n    this.upgradeConnection = function (connprofile, callback) {\n      _resumes[connprofile.returnGUID()] = [callback]; // operation timeout\n\n      setTimeout(function () {\n        delete _resumes[connprofile.returnGUID()];\n      }, _operation_timeout * 1000);\n      var _data = {\n        p: _rsa_pub // RSA publicKey\n\n      };\n      connprofile.setBundle('NSPS', 'pending');\n\n      _this9.sendRouterData(connprofile, 'SP', 'rq', Buf.encode(JSON.stringify(_data)));\n    };\n\n    this.importOperationTimeout = function (timeout) {\n      _operation_timeout = timeout;\n    };\n\n    this.importCryptoModule = function (crypto_module) {\n      _crypto_module = crypto_module;\n    };\n\n    this.importRSA2048KeyPair = function (rsa_priv, rsa_pub) {\n      _rsa_priv = rsa_priv;\n      _rsa_pub = rsa_pub;\n    };\n\n    this.close = function () {\n      _rsa_pub = null;\n      _rsa_priv = null;\n      _resumes = {};\n      _crypto_module = null;\n    };\n  }\n\n  ; // NOOXY crypto Client version\n\n  function NoCrypto() {\n    // to base64\n    var _algo = {\n      // key is in length 32 char\n      AESCBC256: {\n        encryptString: function encryptString(keystr, toEncrypt, callback) {\n          window.crypto.subtle.importKey(\"raw\", //can be \"jwk\" or \"raw\"\n          new TextEncoder('utf-8').encode(keystr), {\n            //this is the algorithm options\n            name: \"AES-CBC\"\n          }, false, //whether the key is extractable (i.e. can be used in exportKey)\n          [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          ).then(function (key) {\n            var iv = new Uint8Array(16);\n            window.crypto.getRandomValues(iv);\n            toEncrypt = new TextEncoder('utf-8').encode(toEncrypt);\n            window.crypto.subtle.encrypt({\n              name: \"AES-CBC\",\n              iv: iv //The initialization vector you used to encrypt\n\n            }, key, //from generateKey or importKey above\n            toEncrypt //ArrayBuffer of the data\n            ).then(function (encrypted) {\n              callback(false, Utils.ArrayBuffertoBase64(iv) + Utils.ArrayBuffertoBase64(encrypted));\n            }).catch(function (err2) {\n              console.error(err2);\n            });\n          }).catch(function (err) {\n            console.error(err);\n          });\n        },\n        decryptString: function decryptString(keystr, toDecrypt, callback) {\n          window.crypto.subtle.importKey(\"raw\", //can be \"jwk\" or \"raw\"\n          new TextEncoder('utf-8').encode(keystr), {\n            //this is the algorithm options\n            name: \"AES-CBC\"\n          }, false, //whether the key is extractable (i.e. can be used in exportKey)\n          [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          ).then(function (key) {\n            var iv = Utils.Base64toArrayBuffer(toDecrypt.substring(0, 24));\n            toDecrypt = Utils.Base64toArrayBuffer(toDecrypt.substring(24));\n            window.crypto.subtle.decrypt({\n              name: \"AES-CBC\",\n              iv: iv //The initialization vector you used to encrypt\n\n            }, key, //from generateKey or importKey above\n            toDecrypt //ArrayBuffer of the data\n            ).then(function (decrypted) {\n              ;\n              callback(false, new TextDecoder('utf-8').decode(decrypted));\n            }).catch(function (err2) {\n              console.error(err2);\n            });\n          }).catch(function (err) {\n            console.error(err);\n          });\n        },\n        encrypt: function encrypt(keystr, toEncrypt, callback) {\n          window.crypto.subtle.importKey(\"raw\", //can be \"jwk\" or \"raw\"\n          new TextEncoder('utf-8').encode(keystr), {\n            //this is the algorithm options\n            name: \"AES-CBC\"\n          }, false, //whether the key is extractable (i.e. can be used in exportKey)\n          [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          ).then(function (key) {\n            var iv = new Uint8Array(16);\n            var salt = new Uint8Array(64);\n            window.crypto.getRandomValues(iv);\n            window.crypto.getRandomValues(salt);\n            window.crypto.subtle.encrypt({\n              name: \"AES-CBC\",\n              iv: iv //The initialization vector you used to encrypt\n\n            }, key, //from generateKey or importKey above\n            Buf.concat([salt, toEncrypt]) //ArrayBuffer of the data\n            ).then(function (encrypted) {\n              try {\n                callback(false, Buf.concat([iv, new Uint8Array(encrypted)]));\n              } catch (e) {\n                console.log(e);\n              }\n            }).catch(function (err2) {\n              console.error(err2);\n            });\n          }).catch(function (err) {\n            console.error(err);\n          });\n        },\n        decrypt: function decrypt(keystr, toDecrypt, callback) {\n          window.crypto.subtle.importKey(\"raw\", //can be \"jwk\" or \"raw\"\n          new TextEncoder('utf-8').encode(keystr), {\n            //this is the algorithm options\n            name: \"AES-CBC\"\n          }, false, //whether the key is extractable (i.e. can be used in exportKey)\n          [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          ).then(function (key) {\n            var iv = toDecrypt.slice(0, 16);\n            window.crypto.subtle.decrypt({\n              name: \"AES-CBC\",\n              iv: iv //The initialization vector you used to encrypt\n\n            }, key, //from generateKey or importKey above\n            toDecrypt.slice(16) //ArrayBuffer of the data\n            ).then(function (decrypted) {\n              ;\n\n              try {\n                callback(false, new Uint8Array(decrypted.slice(64)));\n              } catch (e) {\n                console.log(e);\n              }\n            }).catch(function (err2) {\n              console.error(err2.message);\n            });\n          }).catch(function (err) {\n            console.error(err.message);\n          });\n        }\n      },\n      // Keys is in pem format\n      RSA2048: {\n        encryptString: function encryptString(publicKey, toEncrypt, callback) {\n          window.crypto.subtle.importKey(\"spki\", //can be \"jwk\" (public or private), \"spki\" (public only), or \"pkcs8\" (private only)\n          Utils.convertPemToBinary(publicKey), {\n            //these are the algorithm options\n            name: \"RSA-OAEP\",\n            hash: {\n              name: \"SHA-1\"\n            } //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n\n          }, false, //whether the key is extractable (i.e. can be used in exportKey)\n          [\"encrypt\"] //\"encrypt\" or \"wrapKey\" for public key import or\n          //\"decrypt\" or \"unwrapKey\" for private key imports\n          ).then(function (key) {\n            //returns a publicKey (or privateKey if you are importing a private key)\n            window.crypto.subtle.encrypt({\n              \"name\": \"RSA-OAEP\"\n            }, key, new TextEncoder('utf-8').encode(toEncrypt)).then(function (encrypted) {\n              callback(false, Utils.ArrayBuffertoBase64(encrypted));\n            });\n          }).catch(function (err) {\n            console.log(err);\n          });\n        }\n      }\n    };\n\n    this.returnRandomInt = function (max) {\n      return Math.floor(Math.random() * Math.floor(max));\n    }; // hashing two string (host and client pub key)by SHA256 to get AES-CBC 256 key 32 char\n\n\n    this.generateAESCBC256KeyByHash = function (string1, string2, callback) {\n      window.crypto.subtle.digest(\"SHA-256\", new TextEncoder('utf-8').encode(string1 + string2)).then(function (hash) {\n        callback(false, Utils.ArrayBuffertoBase64(hash).substring(0, 32));\n      });\n    };\n\n    this.encryptString = function (algo, key, toEncrypt, callback) {\n      try {\n        _algo[algo].encryptString(key, toEncrypt, callback);\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    this.decryptString = function (algo, key, toDecrypt, callback) {\n      try {\n        _algo[algo].decryptString(key, toDecrypt, callback);\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    this.encrypt = function (algo, key, toEncrypt, callback) {\n      try {\n        _algo[algo].encrypt(key, toEncrypt, callback);\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    this.decrypt = function (algo, key, toDecrypt, callback) {\n      try {\n        _algo[algo].decrypt(key, toDecrypt, callback);\n      } catch (e) {\n        callback(e);\n      }\n    };\n\n    this.close = function () {};\n  }\n\n  function NoServiceClientCore() {\n    var _this10 = this;\n\n    var verbose = function verbose(tag, log) {\n      if (settings.verbose || settings.debug) {\n        Utils.TagLog(tag, log);\n      }\n\n      ;\n    }; // setup variables\n\n\n    verbose('Core', 'Setting up variables.');\n\n    var _connection = new Connection({\n      allow_ssl_self_signed: false\n    });\n\n    var _authorizationhandler = new AuthorizationHandler();\n\n    var _router = new Router();\n\n    var _activity = new Activity();\n\n    var _implementation = new Implementation();\n\n    var _nsps = new NSPS();\n\n    var _nocrypto = new NoCrypto();\n\n    this.setupDefaultImplementation = function () {\n      verbose('Core', 'Setting up DefaultImplementation.');\n\n      _this10.importOwner(getCookie('NSUser')); // setup NoService Auth implementation\n\n\n      _implementation.setImplement('signin', function (connprofile, data, emitResponse) {\n        window.location.replace(settings.NSc_files_root + 'login.html?conn_method=' + settings.connmethod + '&remote_ip=' + settings.targetip + '&port=' + settings.targetport + '&redirect=' + window.location.href); // window.open('.html.html?conn_method='+conn_method+'&remote_ip='+remote_ip+'&port='+port);\n      });\n\n      _implementation.setImplement('onToken', function (err, token) {\n        setCookie('NSToken', token, 7);\n\n        if (Utils.getQueryVariable('redirect')) {\n          window.location.replace(Utils.getQueryVariable('redirect'));\n        }\n      });\n\n      _implementation.setImplement('setUser', function (err, username) {\n        setCookie('NSUser', username, 365);\n\n        if (!username) {\n          eraseCookie('NSUser');\n        }\n      });\n\n      _implementation.setImplement('logout', function (err, Username) {\n        eraseCookie('NSUser');\n        eraseCookie('NSToken');\n        window.location.reload();\n      });\n\n      _implementation.setImplement('AuthbyTokenFailed', function (connprofile, data, emitResponse) {\n        _implementation.returnImplement('signin')(connprofile, data, emitResponse, 'token');\n      }); // setup NoService Auth implementation\n\n\n      _implementation.setImplement('AuthbyToken', function (connprofile, data, emitResponse) {\n        var callback = function callback(err, token) {\n          var _data = {\n            m: 'TK',\n            d: {\n              t: data.d.t,\n              v: token\n            }\n          };\n          emitResponse(connprofile, _data);\n        };\n\n        var pass = true;\n\n        if (!getCookie('NSToken')) {\n          _implementation.returnImplement('signin')(connprofile, data, emitResponse, 'token');\n        } else {\n          callback(false, getCookie('NSToken'));\n        }\n      }); // setup NoService Auth implementation\n\n\n      _implementation.setImplement('AuthbyPassword', function (connprofile, data, emitResponse) {\n        window.open(settings.NSc_files_root + 'password.html?conn_method=' + settings.connmethod + '&remote_ip=' + settings.targetip + '&port=' + settings.targetport + '&username=' + settings.user + '&authtoken=' + data.d.t + '&redirect=' + window.location.href);\n      });\n\n      _implementation.getDefaultClientConnProfile = function (callback) {\n        _connection.createClient(settings.connmethod, settings.targetip, settings.targetport, callback);\n      };\n\n      verbose('Core', 'Setting up DefaultImplementation done.');\n    };\n\n    this.launch = function () {\n      // create gateway\n      verbose('Core', 'Creating coregateway...');\n      var coregateway = {\n        Settings: settings,\n        AuthorizationHandler: _authorizationhandler,\n        Activity: _activity,\n        Connection: _connection,\n        Router: _router,\n        Utilities: Utils,\n        Implementation: _implementation,\n        NoCrypto: _nocrypto,\n        NSPS: _nsps\n      };\n      verbose('Core', 'Creating coregateway done.');\n\n      _connection.setDebug(settings.debug);\n\n      _connection.importConnectionMethodNameMap(Constants.CONNECTION_METHOD_NAME_MAP); // setup NOOXY Service protocol secure\n\n\n      _nsps.importCryptoModule(_nocrypto); // setup router\n\n\n      if (settings.debug) {\n        _router.addJSONSniffer(function (err, json) {\n          Utils.TagLog('DEBUG', json);\n        });\n      }\n\n      _router.importCore(coregateway); // setup AuthorizationHandler\n\n\n      _authorizationhandler.importImplementation(_implementation); // setup service\n\n\n      _activity.setDebug(settings.debug);\n\n      verbose('Core', 'Setting up variables done.'); //\n\n      verbose('Core', 'NoService client started.');\n    };\n\n    this.logout = function () {\n      _implementation.returnImplement('logout')();\n    };\n\n    this.getImplementationModule = function (callback) {\n      callback(false, _implementation);\n    };\n\n    this.createActivitySocket = function (method, targetip, targetport, service, callback) {\n      _activity.createActivitySocket(method, targetip, targetport, service, settings.user, callback);\n    };\n\n    this.importOwner = function (uname) {\n      settings.user = uname;\n    };\n\n    this.returnOwner = function () {\n      return settings.user;\n    };\n  } // NoService Modules end\n\n\n  var _core = new NoServiceClientCore();\n\n  this.connect = function () {}; // NSc methods\n\n\n  this.setDebug = function (boo) {\n    settings.debug = boo;\n  };\n\n  this.createActivitySocket = function (service, callback) {\n    _core.createActivitySocket(settings.connmethod, settings.targetip, settings.targetport, service, callback);\n  };\n\n  this.setUsername = function (uname) {\n    _core.importOwner(uname);\n  };\n\n  this.returnUsername = function () {\n    return _core.returnOwner();\n  };\n\n  this.logout = function () {\n    _core.logout();\n  };\n\n  this.getImplementationModule = function (callback) {\n    _core.getImplementationModule(callback);\n  };\n\n  this.init = function (targetip, method, targetport) {\n    if (targetip) {\n      settings.targetip = targetip;\n    } // if(settings.debug) {\n    //   settings.connmethod = 'WebSocket';\n    //   settings.targetport = 43582;\n    // }\n\n\n    if (method) {\n      settings.connmethod = method;\n    }\n\n    if (method === 'WebSocketSecure') {\n      settings.targetport = 43581;\n    } else if (method === 'WebSocket') {\n      settings.targetport = 43582;\n    }\n\n    if (targetport) {\n      settings.targetport = targetport;\n    }\n\n    Utils.printLOGO(Constants.version, Constants.copyright);\n    Utils.TagLog('Init', 'host: nsp(' + settings.connmethod + ')://' + targetip + ':' + settings.targetport);\n\n    _core.setupDefaultImplementation();\n\n    try {\n      _core.launch();\n    } catch (e) {\n      settings.connmethod = 'WebSocket';\n\n      _core.launch();\n    }\n  };\n\n  this.init(targetip, method, targetport);\n}\n\n; // module.exports = NSc;\n\nexport default NSc;","map":{"version":3,"sources":["/Users/yves/Software-Dev/NoService-Account/noservice-account/src/flux/NSc.js"],"names":["String","prototype","replaceAll","search","replacement","target","split","join","Buf","alloc","encode","Uint8Array","TextEncoder","decode","TextDecoder","concat","len","args","i","length","result","set","isBuffer","NSc","targetip","method","targetport","setCookie","cname","cvalue","exdays","console","log","d","Date","setTime","getTime","expires","toUTCString","document","cookie","getCookie","name","ca","c","charAt","substring","indexOf","eraseCookie","settings","verbose","debug","user","secure","NSc_files_root","connmethod","Constants","Utils","getQueryVariable","variable","query","window","location","vars","pair","Base64toArrayBuffer","b64str","raw","atob","rawLength","array","ArrayBuffer","charCodeAt","convertPemToBinary","pem","lines","encoded","trim","ArrayBuffertoBase64","buffer","binary","bytes","byteLength","fromCharCode","btoa","printLOGO","version","copyright","TagLog","tag","logstring","JSON","stringify","_space","generateUniqueId","Math","random","toString","substr","generateGUID","s4","floor","searchObject","object","value","prop","hasOwnProperty","Connections","WebSocket","Client","ConnectionProfile","_ws","_debug","setDebug","closeConnetion","close","onData","connprofile","data","onClose","send","connect","ip","port","callback","binaryType","onopen","onmessage","event","onerror","error","onclose","WebSocketSecure","Connection","options","allow_ssl_self_signed","process","env","NODE_TLS_REJECT_UNAUTHORIZED","_default_local_ip_and_port","_servers","_clients","_have_local_server","_blocked_ip","ssl_priv_key","ssl_cert","uint16_heartbeat_phrase","heartbeat_cycle","_conn_meth_name_map","serverId","Rpos","connMethod","hostip","hostport","clientip","conn","_serverId","_pos","_connMethod","_bundle","_GUID","_hostip","_hostport","_clientip","_conn","getServerId","getHostIP","getHostPort","getClientIP","getConnMethod","getRemotePosition","setBundle","key","getBundle","getConn","getGUID","returnServerId","returnHostIP","returnHostPort","returnClientIP","returnConnMethod","returnRemotePosition","returnBundle","returnConn","returnGUID","destroy","worker_cancel_refer","addServer","conn_method","server","Local","Server","start","Object","keys","setInterval","broadcast","e","createClient","remoteip","onData_wrapped","_prev_client","locc","netc","addConnetionModule","constructor","ConnectMethod","err","forEach","conn_profile","getServers","getClients","killClient","bool","importSSLCert","ssl_cert_in","importSSLPrivateKey","ssl_priv_key_in","importHeartBeatCycle","cycle","importConnectionMethodNameMap","dict","Protocols","Protocol","coregateway","emitRequest","Positions","rq","rs","Implementation","Entity","Utilities","AuthorizationHandler","_queue_operation","_auth_timeout","_handler","emitResponse","AuthbyPassword","AuthbyPasswordFailed","AuthbyToken","AuthbyTokenFailed","Signin","RequestHandler","blob","parse","_emitResponse","m","Activity","_ActivityRsCEcallbacks","_to_blob","blob_back","blob_front","slice","_parse_blob","parseInt","json_data","blob_data","on","owner","mode","service","daemon_authkey","_data","t","o","s","od","k","entityId","meta","tempid","ResponseHandler","methods","VE","launchActivitySocketByEntityId","emitASClose","SS","BS","emitBSFReturn","SF","emitSFReturn","CE","onToken","u","AS","emitASData","BE","emitASBlobEvent","n","EV","emitASEvent","CS","Router","_coregateway","_json_sniffers","_raw_sniffers","_locked_ip","_tellJSONSniffers","Json","_tellRAWSniffers","_sessionnotsupport","protocol","session","_senddata","blobfinal","NSPS","isConnectionSecured","secured","encrypt","encrypted","stack","addJSONSniffer","push","addRAWSniffer","importCore","Settings","decrypt","decrypted","er","Service","emitConnectionClose","pt","p","pos","getClientConnProfile","json","sendRouterData","addProtocol","SocketPair","ActivitySocket","service_name","emitter","unbindActivitySocketList","_emitdata","Data","_emit_sfunc","ServiceFunction","_emit_blob_sfunc","BlobServiceFunction","_emitclose","Close","_entity_id","_launched","wait_ops","wait_launch_ops","_sfqueue","_bsfqueue","_on_dict","_on_event","_on_blob_event","exec","launch","setEntityId","id","entities_prev","call","op","returnvalue","callBlob","returnblob","getEntityId","sendData","type","onEvent","onBlobEvent","_emitData","_emitBlobEvent","_emitSFReturn","_emitBSFReturn","_emitEvent","_emitClose","remoteClosed","bundle","splice","ActivitySocketDestroyTimeout","_ASockets","_admin_name","_daemon_auth_key","_on_handler","_emmiter","_unbindActivitySocketList","setTimeout","createActivitySocket","_as","prev","Error","createAdminDaemonActivitySocket","createDaemonActivitySocket","_entitiesId","setDefaultUsername","username","importDaemonAuthKey","importImplementation","returnImplement","apply","_implts","signin","signup","status","token","setImplement","getImplement","returnImplementBundle","_rsa_pub","_rsa_priv","_resumes","_crypto_module","_operation_timeout","host_rsa_pub","client_random_num","returnRandomInt","generateAESCBC256KeyByHash","aes_key","r","a","encryptString","upgradeConnection","succeess","importOperationTimeout","timeout","importCryptoModule","crypto_module","importRSA2048KeyPair","rsa_priv","rsa_pub","NoCrypto","_algo","AESCBC256","keystr","toEncrypt","crypto","subtle","importKey","then","iv","getRandomValues","catch","err2","decryptString","toDecrypt","salt","message","RSA2048","publicKey","hash","max","string1","string2","digest","algo","NoServiceClientCore","_connection","_authorizationhandler","_router","_activity","_implementation","_nsps","_nocrypto","setupDefaultImplementation","importOwner","replace","href","Username","reload","v","pass","open","getDefaultClientConnProfile","CONNECTION_METHOD_NAME_MAP","logout","getImplementationModule","uname","returnOwner","_core","boo","setUsername","returnUsername","init"],"mappings":"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","sourcesContent":["// NoService/clients/javascript/NSc.js\n// Description:\n// \"NSc.js\" is a NoNoService framework client.\n// Copyright 2018-2019 NOOXY. All Rights Reserved.\n'use strict';\n\n// const WebSocket = require('ws');\n// const crypto = require('crypto');\n\n// initialization\nString.prototype.replaceAll = function(search, replacement) {\n    var target = this;\n    return target.split(search).join(replacement);\n};\n// initialization end\n\nlet Buf = {\n  alloc : (...args)=> {\n    // return Buffer.alloc.apply(null, args);\n  },\n\n  encode : (...args)=> {\n    // console.log( new TextEncoder('utf-8').encode(args[0]));\n    return new Uint8Array(new TextEncoder('utf-8').encode(args[0]));\n  },\n\n  decode : (...args)=> {\n    return new TextDecoder('utf-8').decode(args[0]);\n  },\n\n  concat : (...args)=> {\n    let len = 0;\n    for(let i in args[0]) {\n      len += args[0][i].length;\n    }\n    let result = new Uint8Array(len);\n    len = 0;\n    for(let i in args[0]) {\n      result.set(args[0][i], len);\n      len += args[0][i].length;\n    }\n    return result;\n  },\n\n  isBuffer : (...args)=> {\n    return args[0] instanceof Uint8Array;\n  }\n}\n\nfunction NSc(targetip, method, targetport) {\n  const setCookie = (cname, cvalue, exdays)=> {\n    console.log(cname, cvalue, exdays);\n    let d = new Date();\n    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));\n    let expires = \"expires=\"+d.toUTCString();\n    document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";\n  };\n  const getCookie = (cname)=> {\n      let name = cname + \"=\";\n      let ca = document.cookie.split(';');\n      for(let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1);\n        }\n        if (c.indexOf(name) === 0) {\n          return c.substring(name.length, c.length);\n        }\n      }\n      return \"\";\n  };\n  const eraseCookie = (name)=> {\n    setCookie(name,\"\",-1);\n  };\n\n  const settings = {\n    verbose: true,\n    debug: false,\n    user: null,\n    secure: true,\n    NSc_files_root: '/',\n    connmethod: 'WebSocketSecure',\n    targetip: '0.0.0.0',\n    targetport: 43581\n  };\n\n  const Constants = {\n    'version': '0.5.0',\n    'NSP_version': '0.5.0',\n    'copyright': 'copyright(c)2018-2019 NOOXY inc.',\n    \"CONNECTION_METHOD_NAME_MAP\": {\n      \"TCP\": \"TCP\",\n      \"WebSocket\": \"WebSocket\",\n      \"WebSocketSecure\": \"WebSocketSecure\",\n      \"Local\": \"Local\",\n      \"TCP/IP\": \"TCP\",\n      \"ws\": \"WebSocket\",\n      \"wss\": \"WebSocketSecure\",\n      \"local\": \"Local\"\n    }\n  }\n\n  let Utils = {\n    getQueryVariable: (variable)=>{\n           var query = window.location.search.substring(1);\n           var vars = query.split(\"&\");\n           for (var i=0;i<vars.length;i++) {\n                   var pair = vars[i].split(\"=\");\n                   if(pair[0] == variable){return pair[1];}\n           }\n           return(false);\n    },\n    Base64toArrayBuffer: (b64str) => {\n      var raw = window.atob(b64str);\n      var rawLength = raw.length;\n      var array = new Uint8Array(new ArrayBuffer(rawLength));\n      for(let i = 0; i < rawLength; i++) {\n        array[i] = raw.charCodeAt(i);\n      }\n      return array;\n    },\n    convertPemToBinary: (pem)=> {\n      var lines = pem.split('\\n');\n      var encoded = '';\n      for (var i = 0; i < lines.length; i++) {\n        if (lines[i].trim().length > 0 &&\n          lines[i].indexOf('-----BEGIN RSA PRIVATE KEY-----') < 0 &&\n          lines[i].indexOf('-----BEGIN RSA PUBLIC KEY-----') < 0 &&\n          lines[i].indexOf('-----BEGIN PUBLIC KEY-----') < 0 &&\n          lines[i].indexOf('-----END PUBLIC KEY-----') < 0 &&\n          lines[i].indexOf('-----BEGIN PRIVATE KEY-----') < 0 &&\n          lines[i].indexOf('-----END PRIVATE KEY-----') < 0 &&\n          lines[i].indexOf('-----END RSA PRIVATE KEY-----') < 0 &&\n          lines[i].indexOf('-----END RSA PUBLIC KEY-----') < 0) {\n          encoded += lines[i].trim();\n        }\n      }\n      return Utils.Base64toArrayBuffer(encoded)\n    },\n    ArrayBuffertoBase64: (buffer)=> {\n      var binary = '';\n      var bytes = new Uint8Array(buffer);\n      var len = bytes.byteLength;\n      for (var i = 0; i < len; i++) {\n        binary += String.fromCharCode( bytes[ i ] );\n      }\n      return window.btoa( binary );\n    },\n    printLOGO: (version, copyright) => {\n      console.log('88b 88  dP\\'Yb   dP\\'Yb  Yb  dP Yb  dP  TM')\n      console.log('88Yb88 dP   Yb dP   Yb  YbdP   YbdP  ')\n      console.log('88 Y88 Yb   dP Yb   dP  dPYb    88   ')\n      console.log('88  Y8  YbodP   YbodP  dP  Yb   88   NoService framework. ')\n      console.log('')\n      console.log('')\n      console.log('ver. '+version+'. '+copyright)\n      console.log('For more information or update -> www.nooxy.org')\n      console.log('')\n    },\n    TagLog: (tag, logstring) => {\n      if(typeof(logstring)!='string') {\n        logstring = JSON.stringify(logstring, null, 2);\n      }\n      let _space = 10;\n      tag = tag.substring(0, _space);\n      for(var i=0; i < _space-tag.length; i++) {\n        if(i%2 != 1) {\n          tag = tag + ' ';\n        }\n        else {\n          tag = ' ' + tag;\n        }\n      }\n      console.log('['+tag+'] '+logstring.replaceAll('\\n', '\\n['+tag+'] '));\n    },\n    generateUniqueId: () => {\n      return '_' + Math.random().toString(36).substr(2, 9);\n    },\n    generateGUID: () => {\n      let s4 = () => {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +s4() + '-' + s4() + s4() +\n       s4();\n    },\n    searchObject: (object, value)=> {\n      for (let prop in object) {\n        if (object.hasOwnProperty(prop)) {\n          if (object[prop] === value) {\n            return prop;\n          }\n        }\n      }\n    },\n  }\n\n  // NoService Modules\n\n  let Connections = {\n    WebSocket: {\n      Client: function (ConnectionProfile) {\n        let _ws = null;\n        let _debug;\n\n        this.setDebug = (d)=> {\n          _debug = d;\n        };\n\n        this.closeConnetion = () => {\n          _ws.close();\n        };\n\n        this.onData = (connprofile, data) => {Utils.TagLog('*ERR*', 'onData not implemented');};\n\n        this.onClose = () => {Utils.TagLog('*ERR*', 'onClose not implemented');};\n\n        this.send = (connprofile, data)=> {\n          _ws.send(data);\n        };\n\n        this.connect = (ip, port, callback) => {\n          let connprofile;\n          _ws = new WebSocket('ws://'+ip+':'+port);\n          _ws.binaryType = \"arraybuffer\";\n          connprofile = new ConnectionProfile(null, 'Server', 'WebSocket', ip, port, 'localhost', this);\n          _ws.onopen = ()=> {\n            callback(false, connprofile);\n            // ws.send('something');\n          };\n          _ws.onmessage = (event) => {\n            this.onData(connprofile, new Uint8Array(event.data));\n          };\n\n          _ws.onerror = (error) => {\n            if(_debug) {\n              Utils.TagLog('*WARN*', 'An error occured on connection module.');\n              Utils.TagLog('*WARN*', error);\n            }\n            _ws.close();\n            this.onClose(connprofile);\n          };\n\n          _ws.onclose = (error) => {\n              this.onClose(connprofile);\n          };\n\n        }\n      }\n    },\n    WebSocketSecure: {\n      Client: function (ConnectionProfile) {\n        let _ws = null;\n        let _debug;\n\n        this.setDebug = (d)=> {\n          _debug = d;\n        };\n\n        this.closeConnetion = () => {\n          _ws.close();\n        };\n\n        this.onData = (connprofile, data) => {Utils.TagLog('*ERR*', 'onData not implemented');};\n\n        this.onClose = () => {Utils.TagLog('*ERR*', 'onClose not implemented');};\n\n        this.send = (connprofile, data)=> {\n          _ws.send(data);\n        };\n\n        this.connect = (ip, port, callback) => {\n          let connprofile;\n          _ws = new WebSocket('wss://'+ip+':'+port);\n          _ws.binaryType = \"arraybuffer\";\n          connprofile = new ConnectionProfile(null, 'Server', 'WebSocketSecure', ip, port, 'localhost', this);\n          _ws.onopen = ()=> {\n            callback(false, connprofile);\n            // ws.send('something');\n          };\n          _ws.onmessage = (event) => {\n            this.onData(connprofile, new Uint8Array(event.data));\n          };\n\n          _ws.onerror = (error) => {\n            if(_debug) {\n              Utils.TagLog('*WARN*', 'An error occured on connection module.');\n              Utils.TagLog('*WARN*', error);\n            }\n            _ws.close();\n            this.onClose(connprofile);\n          };\n\n          _ws.onclose = (error) => {\n              this.onClose(connprofile);\n          };\n        }\n      }\n    }\n  }\n\n  function Connection(options) {\n    if(options.allow_ssl_self_signed)\n      process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n\n    let _default_local_ip_and_port = '';\n    let _servers = {};\n    let _clients = {};\n    let _have_local_server = false;\n    let _blocked_ip = [];\n    let ssl_priv_key;\n    let ssl_cert;\n    let uint16_heartbeat_phrase = Buf.encode('HB');\n    let heartbeat_cycle = 60000;\n    let _debug = false;\n    let _conn_meth_name_map;\n\n    // define an profile of an connection\n    function ConnectionProfile(serverId, Rpos, connMethod, hostip, hostport, clientip, conn) {\n      let _serverId = serverId;\n      let _pos = Rpos;\n      let _connMethod = connMethod;\n      let _bundle = {};\n      let _GUID = Utils.generateGUID();\n      let _hostip = hostip;\n      let _hostport = hostport;\n      let _clientip = clientip;\n      let _conn = conn; // conn is wrapped!\n\n      if(Rpos === 'Server') {\n        _clients[connMethod+hostip+hostport] = this;\n      }\n\n      this.closeConnetion = () => {\n        if(Rpos === 'Server') {\n          delete _clients[connMethod+hostip+hostport];\n        }\n        // Utils.TagLog('*ERR*', 'closeConnetion not implemented. Of '+this.type);\n        _conn.closeConnetion(_GUID);\n      };\n\n      this.getServerId = (callback) => {callback(false, _serverId);}\n      this.getHostIP = (callback) => {callback(false, _hostip);}\n      this.getHostPort = (callback) => {callback(false, _hostport);}\n      this.getClientIP = (callback) => {callback(false, _clientip);}\n      this.getConnMethod = (callback) => {callback(false, _connMethod);}\n      this.getRemotePosition = (callback) => {callback(false, _pos);}\n      this.setBundle = (key, value) => {_bundle[key] = value;}\n      this.getBundle = (key, callback) => {callback(false, _bundle[key]);}\n      this.getConn = (callback) => {callback(false, _conn)};\n      this.getGUID = (callback) => {callback(false, _GUID)};\n\n      this.returnServerId = () => {return _serverId;}\n      this.returnHostIP = () => {return _hostip;}\n      this.returnHostPort = () => {return _hostport;}\n      this.returnClientIP = () => {return _clientip;}\n      this.returnConnMethod = () => {return _connMethod;}\n      this.returnRemotePosition = () => {return _pos;}\n      this.returnBundle = (key) => {return _bundle[key];}\n      this.returnConn = () => {return _conn;};\n      this.returnGUID = () => {return _GUID};\n\n      this.destroy= () => {\n        // for worker deletetion\n        this.worker_cancel_refer = true;\n        delete _clients[_GUID];\n      };\n      // this.onConnectionDropout = () => {\n      //   Utils.TagLog('*ERR*', 'onConnectionDropout not implemented');\n      // }\n\n    }\n\n    this.addServer = (conn_method, ip, port) => {\n\n      if(conn_method === 'local'||conn_method =='Local') {\n        if(_have_local_server === false) {\n          let _serverId = \"LOCAL\";\n          let server = new Connections.Local.Server(_serverId, ConnectionProfile);\n          _servers[_serverId] = server;\n          server.start('LOCALIP', 'LOCALPORT');\n          server.onData = this.onData;\n          server.onClose = this.onClose;\n          _have_local_server = true;\n        }\n        else {\n          Utils.TagLog('*ERR*', 'Can only exist one local server.');\n        }\n      }\n      else if(_conn_meth_name_map[conn_method]) {\n        let _serverId = Utils.generateUniqueId();\n        let server = new Connections[_conn_meth_name_map[conn_method]].Server(_serverId, ConnectionProfile, ssl_priv_key, ssl_cert);\n        _servers[_serverId] = server;\n        server.start(ip, port);\n        server.onData = this.onData;\n        server.onClose = this.onClose;\n      }\n      else {\n        Utils.TagLog('*ERR*', 'ConnMethod '+conn_method+' not implemented. Skipped.');\n      }\n\n      // Heartbeat\n      if(Object.keys(_servers).length==1) {\n        setInterval(()=>{\n          for(let i in _servers) {\n            try{\n              _servers[i].broadcast(uint16_heartbeat_phrase);\n            }\n            catch(e) {\n              if(_debug) {\n                Utils.TagLog('*WARN*', 'Server '+i+' occured error on heartbeat. Skipped.');\n              }\n            }\n          };\n        }, heartbeat_cycle);\n      };\n    }\n\n    this.createClient = (conn_method, remoteip, port, callback) => {\n      // Heartbeat\n      let onData_wrapped = (connprofile, data)=> {\n        if(data.length!=uint16_heartbeat_phrase.length||data[0]!=uint16_heartbeat_phrase[0]||data[1]!=uint16_heartbeat_phrase[1]) {\n          this.onData(connprofile, data);\n        }\n        else {\n        }\n      };\n\n      let _prev_client = _clients[conn_method+remoteip+port];\n\n      if(_prev_client) {\n        callback(false, _prev_client);\n      }\n      else if(conn_method === 'local'||conn_method =='Local') {\n        if(_have_local_server === false) {\n          Utils.TagLog('*ERR*', 'Local server not started.');\n        }\n        else {\n          let locc = new Connections.Local.Client(ConnectionProfile);\n          locc.setDebug(_debug);\n          locc.onData = onData_wrapped;\n          locc.onClose = this.onClose;\n          locc.connect('LOCALIP', 'LOCALPORT', callback);\n        }\n      }\n\n      else if(_conn_meth_name_map[conn_method]) {\n        let netc = new Connections[_conn_meth_name_map[conn_method]].Client(ConnectionProfile);\n        netc.setDebug(_debug);\n        netc.onData = onData_wrapped;\n        netc.onClose = this.onClose;\n        netc.connect(remoteip, port, callback);\n      }\n\n      else {\n        Utils.TagLog('*ERR*', 'ConnMethod '+conn_method+' not implemented. Skipped.');\n      }\n    };\n\n    this.addConnetionModule = (constructor)=> {\n      Connections[constructor.ConnectMethod] = constructor;\n    };\n\n    this.send = (connprofile, data) => {\n      try {\n        connprofile.getConn((err, conn) => {\n          conn.send(connprofile, data);\n        });\n      }\n      catch (e) {\n        if(_debug) {\n          Utils.TagLog('*WARN*', 'Error occured while sending Data.');\n          console.log(e);\n        }\n      }\n    };\n\n    this.broadcast = (data) => {\n      try {\n        _servers.forEach((key, server) => {\n          server.broadcast(data);\n        });\n      }\n      catch (e) {\n        if(_debug) {\n          Utils.TagLog('*WARN*', 'Error occured while broadcasting Data.');\n          console.log(e);\n        }\n      }\n    };\n\n    this.onData = (conn_profile, data) => {\n      Utils.TagLog('*ERR*', 'Connection module onData not implement');\n    };\n\n    this.onClose = (connprofile) => {\n      Utils.TagLog('*ERR*', 'Connection module onClose not implement');\n    }\n\n    this.getServers = (callback) => {\n      callback(false, _servers);\n    };\n\n    this.getClients = (callback) => {\n      callback(false, _clients);\n    };\n\n    this.killClient = (conn_profile) => {\n\n    };\n\n    this.setDebug = (bool) => {\n      _debug = bool;\n    };\n\n    this.importSSLCert = (ssl_cert_in) => {\n      ssl_cert = ssl_cert_in;\n    };\n\n    this.importSSLPrivateKey = (ssl_priv_key_in) => {\n      ssl_priv_key = ssl_priv_key_in;\n    }\n\n    this.importHeartBeatCycle = (cycle) => {\n      heartbeat_cycle = cycle;\n    };\n\n    this.importConnectionMethodNameMap = (dict)=> {\n      _conn_meth_name_map = dict;\n    };\n\n    this.close = () =>{\n      this.onClose = (connprofile) => {\n        Utils.TagLog('*ERR*', 'Connection module onClose not implement');\n      };\n      this.onData = (conn_profile, data) => {\n        Utils.TagLog('*ERR*', 'Connection module onData not implement');\n      };\n      for(let i in _clients) {\n        _clients[i].closeConnetion();\n      }\n      for(let i in _servers) {\n        _servers[i].close();\n      }\n    }\n  }\n\n  let Protocols = [\n    function Protocol(coregateway, emitRequest) {\n\n      this.Protocol = \"AU\";\n\n      this.Positions = {\n        rq: \"Server\",\n        rs: \"Client\"\n      };\n\n      let Implementation = coregateway.Implementation;\n      let Entity = coregateway.Entity;\n      let Utils = coregateway.Utilities;\n      let AuthorizationHandler = coregateway.AuthorizationHandler;\n\n\n      let _queue_operation = {};\n      let _auth_timeout = 180;\n\n      // ClientSide\n\n      let _handler = {\n        // Authby password\n        'PW': (connprofile, data, emitResponse) => {\n          AuthorizationHandler.AuthbyPassword(connprofile, data, emitResponse);\n        },\n\n        // Authby password failed\n        'PF': (connprofile, data, emitResponse) => {\n          AuthorizationHandler.AuthbyPasswordFailed(connprofile, data, emitResponse);\n        },\n\n        // Authby token\n        'TK': (connprofile, data, emitResponse) => {\n          AuthorizationHandler.AuthbyToken(connprofile, data, emitResponse);\n        },\n\n        // Authby token failed\n        'TF': (connprofile, data, emitResponse) => {\n          AuthorizationHandler.AuthbyTokenFailed(connprofile, data, emitResponse);\n        },\n\n        // Sign in\n        'SI': (connprofile, data, emitResponse) => {\n          AuthorizationHandler.Signin(connprofile, data, emitResponse);\n        },\n\n        'AF': ()=>{\n\n        }\n      };\n\n\n      this.RequestHandler = (connprofile, blob, emitResponse) => {\n        let data = JSON.parse(Buf.decode(blob));\n        let _emitResponse = (connprofile, data)=> {\n          emitResponse(connprofile, Buf.encode(JSON.stringify(data)));\n        };\n        _handler[data.m](connprofile, data, _emitResponse);\n      };\n    }\n    ,\n    function Protocol(coregateway, emitRequest) {\n      this.Protocol = \"CS\";\n\n      this.Positions = {\n        rq: \"Client\",\n        rs: \"Server\"\n      };\n\n      let Activity = coregateway.Activity;\n      let Utils = coregateway.Utilities;\n\n      let _ActivityRsCEcallbacks = {};\n\n      let _to_blob = (data)=> {\n        if(Buf.isBuffer(data.d.d)) {\n          let blob_back = Buf.concat([data.d.d]);\n          data.d.d = null;\n          let blob_front = Buf.encode(JSON.stringify(data));\n          return Buf.concat([Buf.encode(('0000000000000000'+blob_front.length).slice(-16)), blob_front, Buf.encode(('0000000000000000'+blob_back.length).slice(-16)), blob_back]);\n        }\n        else {\n          let blob = Buf.encode(JSON.stringify(data));\n          return Buf.concat([Buf.encode(('0000000000000000'+blob.length).slice(-16)), blob]);\n        }\n      };\n\n      let _parse_blob = (blob)=> {\n        let length = parseInt(Buf.decode(blob.slice(0, 16)));\n        let json_data = JSON.parse(Buf.decode(blob.slice(16, 16+length)));\n        blob = blob.slice(16+length);\n        if(blob.length) {\n          let blob_data;\n          length = parseInt(Buf.decode(blob.slice(0, 16)));\n          blob_data = blob.slice(16, 16+length);\n          json_data.d.d = blob_data;\n          return json_data;\n        }\n        else {\n          return json_data;\n        }\n      };\n\n\n      Activity.on('createActivitySocketRq', (method, targetport, owner, mode, service, targetip, daemon_authkey, callback)=> {\n        let err = false;\n        let _data = {\n          \"m\": \"CE\",\n          \"d\": {\n            t: Utils.generateGUID(),\n            o: owner,\n            m: mode,\n            s: service,\n            od: targetip,\n            k: daemon_authkey\n          }\n        };\n        coregateway.Connection.createClient(method, targetip, targetport, (err, connprofile) => {\n          _ActivityRsCEcallbacks[_data.d.t] = (connprofile, data) => {\n            callback(false, connprofile, data.d.i);\n          }\n          emitRequest(connprofile, 'CS', _to_blob(_data));\n        });\n\n      });\n\n      Activity.on('EmitSSBlobServiceFunctionRq', (conn_profile, entityId, name, data, meta, tempid) => {\n          let _data = {\n            \"m\": \"BS\",\n            \"d\": {\n              \"i\": entityId,\n              \"n\": name,\n              \"t\": tempid,\n              \"d\": data,\n              \"m\": meta\n            }\n          };\n          emitRequest(conn_profile, 'CS', _to_blob(_data));\n\n      });\n\n      Activity.on('EmitSSDataRq', (conn_profile, entityId, d) => {\n          let _data = {\n            \"m\": \"SS\",\n            \"d\": {\n              \"i\": entityId,\n              \"d\": d,\n            }\n          };\n          emitRequest(conn_profile, 'CS', _to_blob(_data));\n\n      });\n\n      Activity.on('EmitSSServiceFunctionRq', (conn_profile, entityId, name, data, tempid) => {\n          let _data = {\n            \"m\": \"SF\",\n            \"d\": {\n              \"i\": entityId,\n              \"n\": name,\n              \"t\": tempid,\n              \"d\": data\n            }\n          };\n          emitRequest(conn_profile, 'CS', _to_blob(_data));\n\n      });\n\n      Activity.on('EmitASCloseRq', (conn_profile, entityId) => {\n          let _data = {\n            \"m\": \"CS\",\n            \"d\": {\n              \"i\": entityId\n            }\n          };\n          emitRequest(conn_profile, 'CS', _to_blob(_data));\n      });\n\n\n      // client\n      this.ResponseHandler = (connprofile, blob) => {\n        let data = _parse_blob(blob);\n        let methods = {\n          // nooxy service protocol implementation of \"Call Service: Vertify Connection\"\n          VE: (connprofile, data) => {\n            if(data.d.s === 'OK') {\n              Activity.launchActivitySocketByEntityId(data.d.i);\n\n            }\n            else {\n              Activity.emitASClose(data.d.i);\n\n            }\n          },\n          // nooxy service protocol implementation of \"Call Service: ServiceSocket\"\n          SS: (connprofile, data) => {\n\n          },\n          // nooxy service protocol implementation of \"Call Service: Blob ServiceFunction\"\n          BS: (connprofile, data) => {\n            if(data.d.s === 'OK') {\n              Activity.emitBSFReturn(data.d.i, false, data.d.t, data.d.d, data.d.m);\n            }\n            else {\n              Activity.emitBSFReturn(data.d.i, true, data.d.t, data.d.d, data.d.m);\n            }\n          },\n          // nooxy service protocol implementation of \"Call Service: ServiceFunction\"\n          SF: (connprofile, data) => {\n            if(data.d.s === 'OK') {\n              Activity.emitSFReturn(data.d.i, false, data.d.t, data.d.d);\n            }\n            else {\n              Activity.emitSFReturn(data.d.i, true, data.d.t, data.d.d);\n            }\n          },\n          // nooxy service protocol implementation of \"Call Service: createEntity\"\n          CE: (connprofile, data) => {\n            // tell server finish create\n            if(data.d.i != null) {\n              // create a description of this service entity.\n              _ActivityRsCEcallbacks[data.d.t](connprofile, data);\n              let _data = {\n                \"m\": \"VE\",\n                \"d\": {\n                  \"i\": data.d.i,\n                }\n              };\n\n              emitRequest(connprofile, 'CS', _to_blob(_data));\n            }\n            else {\n              _ActivityRsCEcallbacks[data.d.t](connprofile, data);\n              delete  _ActivityRsCEcallbacks[data.d.t];\n            }\n          }\n        }\n\n        // call the callback.\n        methods[data.m](connprofile, data);\n      };\n    }\n    ,\n    function Protocol(coregateway, emitRequest) {\n      this.Protocol = \"GT\";\n\n      this.Positions = {\n        rq: \"Client\",\n        rs: \"Server\"\n      };\n\n      this.ResponseHandler = (connprofile, blob) => {\n        let data = JSON.parse(Buf.decode(blob));\n        if(data.s === 'OK') {\n          coregateway.Implementation.onToken(connprofile, false, data.u, data.t);\n        }\n        else {\n          coregateway.Implementation.onToken(connprofile, true, data.u, data.t);\n        }\n      };\n    }\n    ,\n    function Protocol(coregateway, emitRequest) {\n      this.Protocol = \"CA\";\n      this.Positions = {\n        rq: \"Server\",\n        rs: \"Client\"\n      };\n\n      let Activity = coregateway.Activity;\n\n      let _to_blob = (data)=> {\n        if(Buf.isBuffer(data.d.d)) {\n          let blob_back = Buf.concat([data.d.d]);\n          data.d.d = null;\n          let blob_front = Buf.encode(JSON.stringify(data));\n          return Buf.concat([Buf.encode(('0000000000000000'+blob_front.length).slice(-16)), blob_front, Buf.encode(('0000000000000000'+blob_back.length).slice(-16)), blob_back]);\n        }\n        else {\n          let blob = Buf.encode(JSON.stringify(data));\n          return Buf.concat([Buf.encode(('0000000000000000'+blob.length).slice(-16)), blob]);\n        }\n      };\n\n      let _parse_blob = (blob)=> {\n        let length = parseInt(Buf.decode(blob.slice(0, 16)));\n        let json_data = JSON.parse(Buf.decode(blob.slice(16, 16+length)));\n        blob = blob.slice(16+length);\n        if(blob.length) {\n          let blob_data;\n          length = parseInt(Buf.decode(blob.slice(0, 16)));\n          blob_data = blob.slice(16, 16+length);\n          json_data.d.d = blob_data;\n          return json_data;\n        }\n        else {\n          return json_data;\n        }\n      };\n\n      this.RequestHandler = (connprofile, blob, emitResponse) => {\n        let data = _parse_blob(blob);\n\n        let methods = {\n          // nooxy service protocol implementation of \"Call Activity: ActivitySocket\"\n          AS: () => {\n            Activity.emitASData(data.d.i, data.d.d);\n            let _data = {\n              \"m\": \"AS\",\n              \"d\": {\n                // status\n                \"i\": data.d.i,\n                \"s\": \"OK\"\n              }\n            };\n            emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n          },\n          // nooxy service protocol implementation of \"Call Activity: Blob Event(with metadata)\"\n          BE: () => {\n            Activity.emitASBlobEvent(data.d.i, data.d.n, data.d.d, data.d.m);\n            let _data = {\n              \"m\": \"BE\",\n              \"d\": {\n                // status\n                \"i\": data.d.i,\n                \"s\": \"OK\"\n              }\n            };\n            emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n          },\n          // nooxy service protocol implementation of \"Call Activity: Event\"\n          EV: () => {\n            Activity.emitASEvent(data.d.i, data.d.n, data.d.d);\n            let _data = {\n              \"m\": \"EV\",\n              \"d\": {\n                // status\n                \"i\": data.d.i,\n                \"s\": \"OK\"\n              }\n            };\n            emitResponse(connprofile, Buf.encode(JSON.stringify(_data)));\n          },\n          // nooxy service protocol implementation of \"Call Activity: Close ActivitySocket\"\n          CS: () => {\n            Activity.emitASClose(data.d.i);\n          }\n        }\n        // call the callback.\n        methods[data.m](connprofile, data.d, emitResponse);\n      };\n    }\n  ];\n\n  function Router() {\n    let _coregateway;\n    // nooxy service protocol secure\n    let _json_sniffers = [];\n    let _raw_sniffers = [];\n    // for signup timeout\n    let _locked_ip = [];\n    let _debug = false;\n\n    let _tellJSONSniffers = (Json) => {\n      for(let i in _json_sniffers) {\n        _json_sniffers[i](false, Json);\n      }\n    };\n\n    let _tellRAWSniffers = (data) => {\n      for(let i in _raw_sniffers) {\n        _raw_sniffers[i](false, data);\n      }\n    };\n\n    // in case of wrong session of the position\n    let _sessionnotsupport = (protocol, session, data) => {\n      if(_debug) {\n        Utils.TagLog('*WARN*', 'session not support');\n        Utils.TagLog('*WARN*', protocol);\n        Utils.TagLog('*WARN*', session);\n        Utils.TagLog('*WARN*', data);\n      }\n    }\n\n    // a convinient function fo sending data\n    let _senddata = (connprofile, method, session, blob) => {\n      let blobfinal = Buf.concat([Buf.encode(method+session, 'utf8'), blob]);\n      // finally sent the data through the connection.\n      if(connprofile) {\n        _coregateway.NSPS.isConnectionSecured(connprofile, (secured)=> {\n          if(secured === true) {\n            _coregateway.NSPS.encrypt(connprofile, blobfinal, (err, encrypted)=> {\n              if(!err) {\n                _coregateway.Connection.send(connprofile, encrypted);\n              }\n              else if(_debug) {\n                console.log(err);\n                Utils.TagLog('*WARN*', err.stack);\n              }\n            });\n          }\n          else {\n            _coregateway.Connection.send(connprofile, blobfinal);\n          }\n        });\n      }\n    }\n\n    // implementations of NOOXY Service Protocol methods\n    let methods = {\n\n    }\n\n    this.addJSONSniffer = (callback) => {\n      _json_sniffers.push(callback);\n    };\n\n    this.addRAWSniffer = (callback) => {\n      _raw_sniffers.push(callback);\n    };\n\n    // emit specified method.\n    this.emitRequest = (connprofile, method, blob) => {\n      methods[method].emitRequest(connprofile, blob);\n    };\n\n    // import the accessbility of core resource\n    this.importCore = (coregateway) => {\n      _coregateway = coregateway;\n      _debug = _coregateway.Settings.debug;\n\n      // while recieve a data from connection\n      _coregateway.Connection.onData = (connprofile, data) => {\n        _tellRAWSniffers(data);\n        try {\n          if(_coregateway.Settings.secure === true && connprofile.returnConnMethod() != 'Local' && connprofile.returnConnMethod() != 'local') {\n            // upgrade protocol\n            _coregateway.NSPS.decrypt(connprofile, data, (err, decrypted)=> {\n              if(err&&_coregateway.Settings.debug) {\n                console.log(err);\n              }\n              let method = Buf.decode(decrypted.slice(0, 2));\n              let session = Buf.decode(decrypted.slice(2, 4));\n              let blob = decrypted.slice(4);\n              _tellJSONSniffers({method: method, session: session, data: Buf.decode(blob)});\n              methods[method].RequestHandler(connprofile, session, blob);\n            });\n          }\n          else {\n            let method = Buf.decode(data.slice(0, 2));\n            let session = Buf.decode(data.slice(2, 4));\n            let blob = data.slice(4);\n\n            _tellJSONSniffers({method: method, session: session, data: Buf.decode(blob)});\n            methods[method].RequestHandler(connprofile, session, blob);\n          }\n        }\n        catch (er) {\n          if(_debug) {\n            Utils.TagLog('*ERR*', 'An error occured in router module.');\n            console.log(er);\n          }\n        }\n      };\n\n      _coregateway.Connection.onClose = (connprofile) => {\n        try {\n          if(connprofile.returnRemotePosition() === 'Client') {\n            _coregateway.Service.emitConnectionClose(connprofile, (err)=>{\n              connprofile.destroy();\n            });\n          }\n          else {\n            _coregateway.Activity.emitConnectionClose(connprofile, (err)=>{\n              connprofile.destroy();\n            });\n          }\n\n        }\n        catch (er) {\n          if(_debug) {\n            Utils.TagLog('*WARN*', 'An error occured in router module.');\n            console.log(er);\n          }\n        }\n      };\n\n      // load protocols\n      Protocols.forEach((pt)=> {\n        let p = new pt(_coregateway, this.emitRequest, _debug);\n        methods[p.Protocol] = {\n          emitRequest : (connprofile, data) => {\n            _senddata(connprofile, p.Protocol, 'rq', data);\n          },\n\n          RequestHandler : (connprofile, session, data) => {\n            connprofile.getRemotePosition((err, pos)=> {\n              if(p.Positions[session] === pos || p.Positions[session] === 'Both') {\n                let _emitResponse = (connprofile, data)=> {\n                  _senddata(connprofile,  p.Protocol, 'rs', data);\n                };\n                if(session === 'rq') {\n                  p.RequestHandler(connprofile, data, _emitResponse);\n                }\n                else {\n                  p.ResponseHandler(connprofile, data);\n                }\n              }\n              else {\n                _sessionnotsupport(p, session, data);\n              }\n            });\n          }\n        };\n      });\n\n      _coregateway.Implementation.getClientConnProfile = _coregateway.Connection.createClient;\n      _coregateway.Implementation.emitRequest = (connprofile, method, json)=> {this.emitRequest(connprofile, method, Buf.encode(JSON.stringify(json)))};\n      _coregateway.Implementation.sendRouterData = _senddata;\n      _coregateway.NSPS.sendRouterData = _senddata;\n    };\n\n    // for plugins\n    this.addProtocol = (pt)=> {\n      if(_debug) {\n        Utils.TagLog('Router', 'Added a additional protocol.');\n      }\n      Protocols.push(pt);\n    };\n\n    this.close = () => {\n      _coregateway = null;\n      _json_sniffers = [];\n      _raw_sniffers = [];\n      _locked_ip = [];\n    };\n\n  }\n\n  let SocketPair = {\n    ActivitySocket: function ActivitySocket(service_name, conn_profile, emitter, unbindActivitySocketList, debug) {\n      // Service Socket callback\n      let _emitdata = emitter.Data;\n\n      let _emit_sfunc = emitter.ServiceFunction;\n\n      let _emit_blob_sfunc = emitter.BlobServiceFunction;\n\n      let _emitclose = emitter.Close;\n\n      let _entity_id;\n      let _launched = false;\n\n      let wait_ops = [];\n      let wait_launch_ops = [];\n\n      let _sfqueue = {};\n      let _bsfqueue = {};\n\n      let _on_dict = {\n        data: ()=> {\n          if(debug) Utils.TagLog('*WARN*', 'ActivitySocket of service \"'+service_name+'\" on \"data\" not implemented')\n        },\n        close: ()=> {\n          if(debug) Utils.TagLog('*WARN*', 'ActivitySocket of service \"'+service_name+'\" on \"close\" not implemented')\n        }\n      };\n\n      let _on_event = {\n\n      };\n\n      let _on_blob_event = {\n\n      };\n\n      // For waiting connection is absolutly established. We need to wrap operations and make it queued.\n      let exec = (callback) => {\n        if(_launched != false) {\n          callback();\n        }\n        else {\n          wait_ops.push(callback);\n        }\n      };\n\n      this.launch = () => {\n        _launched = true;\n        for(let i in wait_ops) {\n          wait_ops[i]();\n        }\n      };\n\n      this.setEntityId = (id) => {\n        _entity_id = id;\n        let entities_prev = conn_profile.returnBundle('bundle_entities');\n        if(entities_prev != null) {\n          conn_profile.setBundle('bundle_entities', [_entity_id].concat(entities_prev));\n        }\n        else {\n          conn_profile.setBundle('bundle_entities', [_entity_id]);\n        }\n      };\n\n      // ServiceFunction call\n      this.call = (name, data, callback) => {\n        let op = ()=> {\n          let tempid = Utils.generateUniqueId();\n          _sfqueue[tempid] = (err, returnvalue) => {\n            callback(err, returnvalue);\n          };\n          _emit_sfunc(conn_profile, _entity_id, name, data, tempid);\n        };\n        exec(op);\n      }\n\n      // BlobServiceFunction call\n      this.callBlob = (name, blob, meta, callback) => {\n        let op = ()=> {\n          let tempid = Utils.generateUniqueId();\n          _bsfqueue[tempid] = (err, returnblob, meta) => {\n            callback(err, returnblob, meta);\n          };\n          _emit_blob_sfunc(conn_profile, _entity_id, name, blob, meta, tempid);\n        };\n        exec(op);\n      }\n\n      this.getEntityId = (callback) => {\n        callback(false, _entity_id);\n      };\n\n      this.sendData = (data) => {\n        let op = ()=> {\n          _emitdata(conn_profile, _entity_id, data);\n        };\n        exec(op);\n      };\n\n      this.on = (type, callback)=> {\n        _on_dict[type] = callback;\n      };\n\n      this.onEvent = (event, callback)=> {\n        _on_event[event] = callback;\n      };\n\n      this.onBlobEvent = (event, callback)=> {\n        _on_blob_event[event] = callback;\n      };\n\n      this._emitData = (data) => {\n        _on_dict['data'](false, data);\n      };\n\n      this._emitBlobEvent = (event, blob, meta)=> {\n        if(_on_blob_event[event])\n          _on_blob_event[event](false, blob, meta);\n      };\n\n      this._emitSFReturn = (err, tempid, returnvalue) => {\n        if(err) {\n          _sfqueue[tempid](err);\n        }\n        else {\n          _sfqueue[tempid](err, returnvalue);\n        }\n        delete _sfqueue[tempid];\n      };\n\n      this._emitBSFReturn = (err, tempid, returnblob, meta) => {\n        if(err) {\n          _bsfqueue[tempid](err);\n        }\n        else {\n          _bsfqueue[tempid](err, returnblob, meta);\n        }\n        delete _bsfqueue[tempid];\n      };\n\n      this._emitEvent = (event, data)=> {\n        if(_on_event[event])\n          _on_event[event](false, data);\n      };\n\n      this._emitClose = () => {\n        _on_dict['close'](false);\n      };\n\n      this.remoteClosed = false;\n\n      this.unbindActivitySocketList = ()=> {\n        Utils.TagLog('*ERR*', '_aftercloseLaunched not implemented');\n      };\n\n      this.close = () => {\n        let op = ()=> {\n          if(!this.remoteClosed)\n            _emitclose(conn_profile, _entity_id);\n          this._emitClose();\n          let bundle = conn_profile.returnBundle('bundle_entities');\n          for (let i=bundle.length-1; i>=0; i--) {\n            if (bundle[i] === _entity_id) {\n              unbindActivitySocketList(_entity_id);\n              bundle.splice(i, 1);\n            }\n          }\n          conn_profile.setBundle('bundle_entities', bundle);\n          if(bundle.length === 0) {\n            conn_profile.closeConnetion();\n          }\n        }\n        exec(op);\n      };\n    }\n  }\n\n\n  function Activity() {\n    let ActivitySocketDestroyTimeout = 1000;\n    let _ASockets = {};\n    let _admin_name = 'admin';\n    let _daemon_auth_key;\n    let _debug = false;\n    let _on_handler = {};\n\n    let _emmiter;\n\n\n\n    let _unbindActivitySocketList = (_entity_id)=> {\n      setTimeout(()=>{\n        // tell worker abort referance\n        if(_ASockets[_entity_id])\n          _ASockets[_entity_id].worker_cancel_refer = true;\n        delete _ASockets[_entity_id];\n      }, ActivitySocketDestroyTimeout);\n    };\n\n    // Service module create activity socket\n    this.createActivitySocket = (method, targetip, targetport, service, owner, callback) => {\n      _emmiter = {\n        Data: _on_handler['EmitSSDataRq'],\n        ServiceFunction: _on_handler['EmitSSServiceFunctionRq'],\n        Close: _on_handler['EmitASCloseRq'],\n      }\n      _on_handler['createActivitySocketRq'](method, targetport, owner, 'normal', service, targetip, false, (err, connprofile, entityId)=> {\n        if(entityId) {\n          let _as = new SocketPair.ActivitySocket(service, connprofile, _emmiter, _unbindActivitySocketList, _debug);\n          _as.setEntityId(entityId);\n          let prev = connprofile.returnBundle();\n          if(!prev) {\n            prev = [];\n          }\n          connprofile.setBundle('bundle_entities', prev.concat(entityId));\n          _ASockets[entityId] = _as;\n          callback(false, _ASockets[entityId]);\n        }\n        else{\n          callback(new Error('Could not create this entity for some reason.'));\n        }\n      });\n    };\n\n    this.createAdminDaemonActivitySocket = (method, targetip, targetport, service, callback) => {\n      this.createDaemonActivitySocket(method, targetip, targetport, service, _admin_name, callback);\n    };\n\n    this.createDaemonActivitySocket = (method, targetip, targetport, service, owner, callback) => {\n      _emmiter = {\n        Data: _on_handler['EmitSSDataRq'],\n        ServiceFunction: _on_handler['EmitSSServiceFunctionRq'],\n        BlobServiceFunction: _on_handler['EmitSSBlobServiceFunctionRq'],\n        Close: _on_handler['EmitASCloseRq'],\n      }\n      _on_handler['createActivitySocketRq'](method, targetport, owner, 'daemon', service, targetip, _daemon_auth_key, (err, connprofile, entityId)=> {\n        if(entityId) {\n          let _as = new SocketPair.ActivitySocket(service, connprofile, _emmiter, _unbindActivitySocketList, _debug);\n          _as.setEntityId(entityId);\n          let prev = connprofile.returnBundle();\n          if(!prev) {\n            prev = [];\n          }\n          connprofile.setBundle('bundle_entities', prev.concat(entityId));\n          _ASockets[entityId] = _as;\n          callback(false, _ASockets[entityId]);\n        }\n        else{\n          callback(new Error('Could not create this entity for some reason.'));\n        }\n      });\n    };\n\n    this.emitASClose = (entityId)=> {\n      _ASockets[entityId].remoteClosed = true;\n      _ASockets[entityId]._emitClose();\n    };\n\n    this.emitASData = (entityId, data)=> {\n      _ASockets[entityId]._emitData(data);\n    };\n\n    this.emitBSFReturn = (entityId, err, tempid, returnvalue, meta)=> {\n      _ASockets[entityId]._emitBSFReturn(err, tempid, returnvalue, meta);\n    };\n\n    this.emitSFReturn = (entityId, err, tempid, returnvalue)=> {\n      _ASockets[entityId]._emitSFReturn(err, tempid, returnvalue);\n    };\n\n    this.emitASData = (entityId, data)=> {\n      _ASockets[entityId]._emitData(data);\n    };\n\n    this.emitASEvent = (entityId, event, data)=> {\n      _ASockets[entityId]._emitEvent(event, data);\n    };\n\n    this.emitASBlobEvent = (entityId, event, blob, meta)=> {\n      _ASockets[entityId]._emitBlobEvent(event, blob, meta);\n    };\n\n    this.launchActivitySocketByEntityId = (entityId)=> {\n      _ASockets[entityId].launch();\n    };\n\n    this.emitConnectionClose = (connprofile, callback) => {\n      let _entitiesId = connprofile.returnBundle('bundle_entities');\n      for(let i in _entitiesId) {\n        _ASockets[_entitiesId[i]]._emitClose();\n        setTimeout(()=>{\n          // for worker abort referance\n          if(_ASockets[_entitiesId[i]]) {\n            _ASockets[_entitiesId[i]].worker_cancel_refer = true;\n            delete _ASockets[_entitiesId[i]];\n          }\n        }, ActivitySocketDestroyTimeout);\n      }\n      callback(false);\n    };\n\n    this.setDefaultUsername = (username)=> {\n      _admin_name = username;\n    };\n\n    this.setDebug = (debug)=> {\n      _debug = debug;\n    };\n\n    this.importDaemonAuthKey = (key) => {\n      _daemon_auth_key = key;\n    };\n\n    this.on = (event, callback)=> {\n      _on_handler[event] = callback;\n    };\n\n    this.close = ()=> {\n      ActivitySocketDestroyTimeout = 1000;\n      for(let i in _ASockets) {\n        _ASockets[i].worker_cancel_refer = true;\n        delete _ASockets[i];\n      }\n      _ASockets = {};\n      _emmiter = null;\n      _admin_name = 'admin';\n      _daemon_auth_key = null;\n      _debug = false;\n       _on_handler = {};\n    };\n  };\n\n  // Handling responses to authorization requests.\n  function AuthorizationHandler() {\n\n    this.importImplementation = (Implementation)=> {\n      this.AuthbyPassword = (...args)=> {Implementation.returnImplement('AuthbyPassword').apply(null, args)};\n      this.AuthbyToken = (...args)=> {Implementation.returnImplement('AuthbyToken').apply(null, args)};\n      this.AuthbyTokenFailed = (...args)=> {Implementation.returnImplement('AuthbyTokenFailed').apply(null, args)};\n      this.Signin = (...args)=> {Implementation.returnImplement('signin').apply(null, args)};\n\n    };\n\n    this.close = () =>{\n\n    }\n  };\n\n  function Implementation() {\n\n    let _implts = {\n      // NOOXY service protocol sercure end\n      // return for Server\n      AuthbyToken: () => {\n        Utils.TagLog('*ERR*', 'AuthbyToken not implemented');\n      },\n\n      AuthbyTokenFailed: () => {\n        Utils.TagLog('*ERR*', 'AuthbyTokenFailed not implemented');\n      },\n\n      // return for Server\n      AuthbyPassword: () => {\n        Utils.TagLog('*ERR*', 'AuthbyPassword not implemented');\n      },\n\n      AuthbyPasswordFailed: () => {\n        Utils.TagLog('*ERR*', 'AuthbyPasswordFailed not implemented');\n      },\n\n      // return for Client\n      signin: () => {\n        Utils.TagLog('*ERR*', 'signin not implemented');\n      },\n\n      // return for Client\n      signup: () => {\n        Utils.TagLog('*ERR*', 'signup not implemented');\n      },\n\n      onToken: () => {\n        Utils.TagLog('*ERR*', 'onToken not implemented');\n      }\n    };\n\n\n    this.onToken = (connprofile, status, username, token)=> {\n      _implts['onToken'](status, token, username);\n    };\n\n    this.setImplement = (name, callback) => {\n      _implts[name] = callback;\n    };\n\n    this.returnImplement = (name) => {\n      return _implts[name];\n    };\n\n    this.getImplement = (name, callback) => {\n      callback(false, _implts[name]);\n    };\n\n    this.returnImplementBundle = () => {\n      return _implts;\n    };\n\n    this.getClientConnProfile = ()=> {\n\n    };\n\n    this.close = () => {};\n  }\n\n  // NOOXY service protocol secure\n  function NSPS() {\n    let _rsa_pub;\n    let _rsa_priv;\n    let _resumes = {};\n    let _crypto_module;\n    let _operation_timeout = 60; // seconds\n\n    this.emitRequest = () => {console.log('[*ERR*] emitRequest not implemented');};\n\n    // Nooxy service protocol secure request ClientSide\n    // in client need to be in implementation module\n    this.RequestHandler = (connprofile, blob) => {\n      let data = JSON.parse(Buf.decode(blob));\n      let host_rsa_pub = data.p;\n      let client_random_num = _crypto_module.returnRandomInt(99999);\n      connprofile.setBundle('host_rsa_pub_key', host_rsa_pub);\n      _crypto_module.generateAESCBC256KeyByHash(host_rsa_pub, client_random_num, (err, aes_key) => {\n        connprofile.setBundle('aes_256_cbc_key', aes_key);\n        let _data = {\n          r: client_random_num,\n          a: aes_key// aes key to vertify\n        };\n        _crypto_module.encryptString('RSA2048', host_rsa_pub, JSON.stringify(_data), (err, encrypted)=> {\n          if(err) {\n            console.log(err);\n          }\n          else {\n            this.sendRouterData(connprofile, 'SP', 'rs', Buf.encode(JSON.stringify(encrypted)));\n            connprofile.setBundle('NSPS', true);\n          }\n\n        });\n      });\n    };\n\n    this.encrypt = (connprofile, blob, callback)=> {\n      connprofile.getBundle('aes_256_cbc_key', (err, key)=>{\n        _crypto_module.encrypt('AESCBC256', key, blob, (err, encrypted)=> {\n          callback(err, encrypted);\n        });\n      });\n    };\n\n    this.decrypt = (connprofile, blob, callback)=> {\n      if(connprofile.returnBundle('NSPS') === 'pending') {\n        let method = Buf.decode(blob.slice(0, 2));\n        if(method === 'SP') {\n          let session = Buf.decode(blob.slice(2, 4));\n          if(session === 'rs') {\n            let data = blob.slice(4);\n            this.ResponseHandler(connprofile, data);\n          }\n        }\n        else {\n          _resumes[connprofile.returnGUID()].push(()=> {callback(false, blob)});\n        }\n      }\n      else if(connprofile.returnBundle('NSPS') != true && connprofile.returnRemotePosition() === 'Client') {\n        this.upgradeConnection(connprofile, (err, succeess)=>{\n          if(succeess) {\n            callback(false, blob);\n          }\n          else {\n            connprofile.closeConnetion();\n          }\n          if(err) {\n            console.log(err);\n          }\n        });\n      }\n      else if(connprofile.returnBundle('NSPS') != true  && connprofile.returnRemotePosition() === 'Server') {\n        let method = Buf.decode(blob.slice(0, 2));\n        if(method === 'SP') {\n          let session = Buf.decode(blob.slice(2, 4));\n          if(session === 'rq') {\n            let data = blob.slice(4);\n            this.RequestHandler(connprofile, data);\n          }\n        }\n        else {\n          callback(false, blob);\n        }\n\n      }\n      else if(connprofile.returnBundle('NSPS') === true) {\n        _crypto_module.decrypt('AESCBC256', connprofile.returnBundle('aes_256_cbc_key'), blob, (err, decrypted)=> {\n          callback(err, decrypted);\n        });\n      }\n    };\n\n    this.isConnectionSecured = (connprofile, callback)=> {\n      connprofile.getBundle('NSPS', (err, NSPS)=>{\n        // if(NSPS === 'finalize') {\n        //   connprofile.setBundle('NSPS', true);\n        //   callback(false);\n        // }\n        // else {\n          callback(NSPS);\n        // }\n      });\n    };\n\n    this.upgradeConnection = (connprofile, callback) => {\n      _resumes[connprofile.returnGUID()] = [callback];\n      // operation timeout\n      setTimeout(()=>{\n        delete _resumes[connprofile.returnGUID()];\n      }, _operation_timeout*1000);\n\n      let _data = {\n        p: _rsa_pub// RSA publicKey\n      };\n      connprofile.setBundle('NSPS', 'pending');\n      this.sendRouterData(connprofile, 'SP', 'rq', Buf.encode(JSON.stringify(_data)));\n    }\n\n    this.importOperationTimeout = (timeout) => {\n      _operation_timeout = timeout;\n    };\n\n    this.importCryptoModule = (crypto_module) => {\n      _crypto_module = crypto_module;\n    }\n\n    this.importRSA2048KeyPair = (rsa_priv, rsa_pub) => {\n      _rsa_priv = rsa_priv;\n      _rsa_pub = rsa_pub;\n    };\n\n    this.close = () => {\n      _rsa_pub = null;\n      _rsa_priv = null;\n      _resumes = {};\n      _crypto_module = null;\n    };\n  };\n\n  // NOOXY crypto Client version\n  function NoCrypto() {\n    // to base64\n    let _algo = {\n      // key is in length 32 char\n      AESCBC256: {\n        encryptString: (keystr, toEncrypt, callback) => {\n          window.crypto.subtle.importKey(\n              \"raw\", //can be \"jwk\" or \"raw\"\n              new TextEncoder('utf-8').encode(keystr),\n              {   //this is the algorithm options\n                  name: \"AES-CBC\",\n              },\n              false, //whether the key is extractable (i.e. can be used in exportKey)\n              [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          )\n          .then((key)=>{\n            let iv = new Uint8Array(16);\n            window.crypto.getRandomValues(iv);\n            toEncrypt = new TextEncoder('utf-8').encode(toEncrypt);\n            window.crypto.subtle.encrypt(\n              {\n                  name: \"AES-CBC\",\n                  iv: iv, //The initialization vector you used to encrypt\n              },\n              key, //from generateKey or importKey above\n              toEncrypt //ArrayBuffer of the data\n            )\n            .then((encrypted)=>{\n              callback(false, Utils.ArrayBuffertoBase64(iv)+Utils.ArrayBuffertoBase64(encrypted));\n            })\n            .catch((err2)=>{\n              console.error(err2);\n            });\n          })\n          .catch((err)=>{\n              console.error(err);\n          });\n        },\n        decryptString: (keystr, toDecrypt, callback) => {\n          window.crypto.subtle.importKey(\n              \"raw\", //can be \"jwk\" or \"raw\"\n              new TextEncoder('utf-8').encode(keystr),\n              {   //this is the algorithm options\n                  name: \"AES-CBC\",\n              },\n              false, //whether the key is extractable (i.e. can be used in exportKey)\n              [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          )\n          .then((key)=>{\n            let iv = Utils.Base64toArrayBuffer(toDecrypt.substring(0, 24));\n            toDecrypt = Utils.Base64toArrayBuffer(toDecrypt.substring(24));\n            window.crypto.subtle.decrypt(\n              {\n                  name: \"AES-CBC\",\n                  iv: iv, //The initialization vector you used to encrypt\n              },\n              key, //from generateKey or importKey above\n              toDecrypt //ArrayBuffer of the data\n            )\n            .then((decrypted)=>{;\n              callback(false, new TextDecoder('utf-8').decode(decrypted));\n            })\n            .catch((err2)=>{\n              console.error(err2);\n            });\n          })\n          .catch((err)=>{\n              console.error(err);\n          });\n        },\n        encrypt: (keystr, toEncrypt, callback) => {\n          window.crypto.subtle.importKey(\n              \"raw\", //can be \"jwk\" or \"raw\"\n              new TextEncoder('utf-8').encode(keystr),\n              {   //this is the algorithm options\n                  name: \"AES-CBC\",\n              },\n              false, //whether the key is extractable (i.e. can be used in exportKey)\n              [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          )\n          .then((key)=>{\n            let iv = new Uint8Array(16);\n            let salt = new Uint8Array(64);\n            window.crypto.getRandomValues(iv);\n            window.crypto.getRandomValues(salt);\n            window.crypto.subtle.encrypt(\n              {\n                  name: \"AES-CBC\",\n                  iv: iv, //The initialization vector you used to encrypt\n              },\n              key, //from generateKey or importKey above\n              Buf.concat([salt, toEncrypt]) //ArrayBuffer of the data\n            )\n            .then((encrypted)=>{\n              try {\n                callback(false, Buf.concat([iv, new Uint8Array(encrypted)]));\n              }\n              catch (e) {\n                console.log(e);\n              }\n            })\n            .catch((err2)=>{\n              console.error(err2);\n            });\n          })\n          .catch((err)=>{\n              console.error(err);\n          });\n        },\n        decrypt: (keystr, toDecrypt, callback) => {\n          window.crypto.subtle.importKey(\n              \"raw\", //can be \"jwk\" or \"raw\"\n              new TextEncoder('utf-8').encode(keystr),\n              {   //this is the algorithm options\n                  name: \"AES-CBC\",\n              },\n              false, //whether the key is extractable (i.e. can be used in exportKey)\n              [\"encrypt\", \"decrypt\"] //can be \"encrypt\", \"decrypt\", \"wrapKey\", or \"unwrapKey\"\n          )\n          .then((key)=>{\n            let iv = toDecrypt.slice(0, 16);\n            window.crypto.subtle.decrypt(\n              {\n                  name: \"AES-CBC\",\n                  iv: iv, //The initialization vector you used to encrypt\n              },\n              key, //from generateKey or importKey above\n              toDecrypt.slice(16) //ArrayBuffer of the data\n            )\n            .then((decrypted)=>{;\n              try {\n                callback(false, new Uint8Array(decrypted.slice(64)));\n              }\n              catch(e) {\n                console.log(e);\n              }\n            })\n            .catch((err2)=>{\n              console.error(err2.message);\n            });\n          })\n          .catch((err)=>{\n              console.error(err.message);\n          });\n        }\n      },\n\n      // Keys is in pem format\n      RSA2048: {\n        encryptString: (publicKey, toEncrypt, callback) => {\n          window.crypto.subtle.importKey(\n            \"spki\", //can be \"jwk\" (public or private), \"spki\" (public only), or \"pkcs8\" (private only)\n            Utils.convertPemToBinary(publicKey),\n            {   //these are the algorithm options\n                name: \"RSA-OAEP\",\n                hash: {name: \"SHA-1\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n            },\n            false, //whether the key is extractable (i.e. can be used in exportKey)\n            [\"encrypt\"] //\"encrypt\" or \"wrapKey\" for public key import or\n                        //\"decrypt\" or \"unwrapKey\" for private key imports\n          )\n          .then((key)=> {\n              //returns a publicKey (or privateKey if you are importing a private key)\n            window.crypto.subtle.encrypt({\"name\": \"RSA-OAEP\"}, key, new TextEncoder('utf-8').encode(toEncrypt)).then((encrypted)=>{\n              callback(false, Utils.ArrayBuffertoBase64(encrypted));\n            });\n\n          })\n          .catch((err)=>{\n              console.log(err);\n          });\n\n        }\n      },\n\n    };\n\n    this.returnRandomInt = (max) => {\n      return Math.floor(Math.random() * Math.floor(max));\n    }\n\n    // hashing two string (host and client pub key)by SHA256 to get AES-CBC 256 key 32 char\n    this.generateAESCBC256KeyByHash = (string1, string2, callback) => {\n      window.crypto.subtle.digest(\"SHA-256\", new TextEncoder('utf-8').encode(string1+string2)).then((hash)=> {\n        callback(false, (Utils.ArrayBuffertoBase64(hash)).substring(0, 32));\n      });\n    };\n\n    this.encryptString = (algo, key, toEncrypt, callback) => {\n      try{\n        _algo[algo].encryptString(key, toEncrypt, callback);\n      }\n      catch(e) {\n        callback(e);\n      }\n\n    };\n\n    this.decryptString = (algo, key, toDecrypt, callback) => {\n      try {\n        _algo[algo].decryptString(key, toDecrypt, callback);\n      }\n      catch(e) {\n        callback(e);\n      }\n\n    };\n\n    this.encrypt = (algo, key, toEncrypt, callback) => {\n      try{\n        _algo[algo].encrypt(key, toEncrypt, callback);\n      }\n      catch(e) {\n        callback(e);\n      }\n\n    };\n\n    this.decrypt = (algo, key, toDecrypt, callback) => {\n      try {\n        _algo[algo].decrypt(key, toDecrypt, callback);\n      }\n      catch(e) {\n        callback(e);\n      }\n    };\n\n    this.close = () => {};\n  }\n\n  function NoServiceClientCore() {\n    let verbose = (tag, log) => {\n      if(settings.verbose||settings.debug) {\n        Utils.TagLog(tag, log);\n      };\n    };\n    // setup variables\n    verbose('Core', 'Setting up variables.')\n    let _connection = new Connection({allow_ssl_self_signed: false});\n    let _authorizationhandler = new AuthorizationHandler();\n    let _router = new Router();\n    let _activity = new Activity();\n    let _implementation = new Implementation();\n    let _nsps = new NSPS();\n    let _nocrypto = new NoCrypto;\n\n    this.setupDefaultImplementation = ()=> {\n      verbose('Core', 'Setting up DefaultImplementation.');\n      this.importOwner(getCookie('NSUser'));\n      // setup NoService Auth implementation\n      _implementation.setImplement('signin', (connprofile, data, emitResponse)=>{\n        window.location.replace(settings.NSc_files_root+'login.html?conn_method='+settings.connmethod+'&remote_ip='+settings.targetip+'&port='+settings.targetport+'&redirect='+window.location.href);\n        // window.open('.html.html?conn_method='+conn_method+'&remote_ip='+remote_ip+'&port='+port);\n      });\n\n      _implementation.setImplement('onToken', (err, token)=>{\n        setCookie('NSToken', token, 7);\n        if(Utils.getQueryVariable('redirect')) {\n          window.location.replace(Utils.getQueryVariable('redirect'));\n        }\n      });\n\n      _implementation.setImplement('setUser', (err, username)=>{\n        setCookie('NSUser', username, 365);\n        if(!username) {\n          eraseCookie('NSUser');\n        }\n      });\n\n      _implementation.setImplement('logout', (err, Username)=>{\n        eraseCookie('NSUser');\n        eraseCookie('NSToken');\n        window.location.reload();\n      });\n\n      _implementation.setImplement('AuthbyTokenFailed', (connprofile, data, emitResponse)=>{\n        _implementation.returnImplement('signin')(connprofile, data, emitResponse, 'token');\n      });\n\n      // setup NoService Auth implementation\n      _implementation.setImplement('AuthbyToken', (connprofile, data, emitResponse) => {\n        let callback = (err, token)=>{\n          let _data = {\n            m:'TK',\n            d:{\n              t: data.d.t,\n              v: token\n            }\n          }\n          emitResponse(connprofile, _data);\n        };\n\n        let pass = true;\n        if(!getCookie('NSToken')) {\n          _implementation.returnImplement('signin')(connprofile, data, emitResponse, 'token');\n        }\n        else {\n          callback(false, getCookie('NSToken'));\n        }\n\n      });\n      // setup NoService Auth implementation\n\n      _implementation.setImplement('AuthbyPassword', (connprofile, data, emitResponse) => {\n        window.open(settings.NSc_files_root+'password.html?conn_method='+settings.connmethod+'&remote_ip='+settings.targetip+'&port='+settings.targetport+'&username='+settings.user+'&authtoken='+data.d.t+'&redirect='+window.location.href);\n      });\n\n      _implementation.getDefaultClientConnProfile = (callback) => {\n        _connection.createClient(settings.connmethod, settings.targetip, settings.targetport, callback);\n      }\n\n      verbose('Core', 'Setting up DefaultImplementation done.');\n\n    };\n\n    this.launch = () => {\n      // create gateway\n      verbose('Core', 'Creating coregateway...')\n      let coregateway = {\n          Settings: settings,\n          AuthorizationHandler: _authorizationhandler,\n          Activity : _activity,\n          Connection: _connection,\n          Router: _router,\n          Utilities: Utils,\n          Implementation: _implementation,\n          NoCrypto: _nocrypto,\n          NSPS: _nsps\n        };\n      verbose('Core', 'Creating coregateway done.');\n\n      _connection.setDebug(settings.debug);\n      _connection.importConnectionMethodNameMap(Constants.CONNECTION_METHOD_NAME_MAP);\n\n      // setup NOOXY Service protocol secure\n      _nsps.importCryptoModule(_nocrypto);\n\n      // setup router\n      if(settings.debug) {\n        _router.addJSONSniffer((err, json)=> {\n          Utils.TagLog('DEBUG', json);\n        });\n      }\n      _router.importCore(coregateway);\n\n      // setup AuthorizationHandler\n      _authorizationhandler.importImplementation(_implementation);\n\n      // setup service\n      _activity.setDebug(settings.debug);\n\n      verbose('Core', 'Setting up variables done.');\n      //\n      verbose('Core', 'NoService client started.');\n    }\n\n    this.logout = ()=> {\n      _implementation.returnImplement('logout')();\n    };\n\n    this.getImplementationModule = (callback) => {\n      callback(false, _implementation);\n    };\n\n    this.createActivitySocket = (method, targetip, targetport, service, callback) => {\n      _activity.createActivitySocket(method, targetip, targetport, service, settings.user, callback);\n    };\n\n    this.importOwner = (uname)=> {\n      settings.user = uname;\n    };\n\n    this.returnOwner = ()=> {\n      return settings.user;\n    }\n  }\n\n  // NoService Modules end\n\n  let _core = new NoServiceClientCore();\n\n  this.connect = ()=> {};\n  // NSc methods\n  this.setDebug = (boo)=>{\n    settings.debug = boo;\n  }\n  this.createActivitySocket = (service, callback) => {\n    _core.createActivitySocket(settings.connmethod, settings.targetip, settings.targetport, service, callback);\n  };\n  this.setUsername = (uname)=>{\n    _core.importOwner(uname);\n  }\n  this.returnUsername = ()=>{\n    return _core.returnOwner();\n  };\n  this.logout = ()=> {\n    _core.logout();\n  };\n  this.getImplementationModule = (callback)=> {\n    _core.getImplementationModule(callback);\n  };\n  this.init = (targetip, method, targetport) => {\n    if(targetip) {\n      settings.targetip = targetip;\n    }\n\n    // if(settings.debug) {\n    //   settings.connmethod = 'WebSocket';\n    //   settings.targetport = 43582;\n    // }\n\n    if(method) {\n      settings.connmethod = method;\n    }\n\n    if(method === 'WebSocketSecure') {\n      settings.targetport = 43581;\n    }\n    else if (method ==='WebSocket') {\n      settings.targetport = 43582;\n    }\n\n    if(targetport) {\n      settings.targetport = targetport;\n    }\n\n    Utils.printLOGO(Constants.version, Constants.copyright);\n\n    Utils.TagLog('Init', 'host: nsp('+settings.connmethod+')://'+targetip+':'+settings.targetport);\n    _core.setupDefaultImplementation();\n\n    try {\n      _core.launch();\n    }\n    catch(e) {\n      settings.connmethod = 'WebSocket';\n      _core.launch();\n    }\n\n  };\n  this.init(targetip, method, targetport);\n};\n\n// module.exports = NSc;\nexport default NSc;\n"]},"metadata":{},"sourceType":"module"}